#!/bin/bash

# Hardcoded defaults
#	Immutable
main_directory="$HOME/.playlister/"
config_file="${main_directory}playlister.conf"
help_file="${main_directory}playlister.help"
playlist_ext=".plst"
mp3_ext=".mp3"
backup_ext=".bak"
tmp_file="/tmp/playlister-1234321.tmp"
#	Mutable
playlist_directory="${main_directory}playlists/"
mp3_directory="${main_directory}mp3s/"

declare -A configs=( 
	["main_directory"]="$main_directory" \
	["config_file"]="$config_file" \
	["help_file"]="$help_file" \
	["playlist_directory"]="$playlist_directory" \
	["mp3_directory"]="$mp3_directory" \
)

declare -a configs_mutable=(
	"mp3_directory" \
	"playlist_directory"
)

function main () {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-correct-argument-count "main" ">" 0 "$@"
	while [[ "$#" -gt 0 ]]; do
		case $1 in 
			config)
				shift
				config "$@"
				exit 0
				;;
			show)
				shift
				read-config-if-exists
				show "$@"
				exit 1
				;;
			*)
				output-failure "unrecognised option:\"$1\""
				shift
				exit 1
				;;
		esac
	done
}

function assert-correct-argument-count () {
	# Check if function given correct arg amount.
	# return execution flow on success, exit 1 on failure
		# success: correct arg count given to function
		# failure:
			# wrong arg count given to assert-corr...
			# invalid operator given
			# assertion failed
	# Arguments:
		# func 				-> name of function (needed for failure output)
		# operator 			-> keyword together with argcount specifying the argument count
		# argcount 			-> a point of refrence for arguments expected
		# optional arguments... 	-> arguments given originally to func
	# the func arguments need to be inputted with [@] (protect from "My Argument" arguments with [*])
	if ! [[ $# -ge 3 ]]; then
		output-failure "assert-correct-argument-count: invalid argument count(must be >= 3, but {$#} were given)"
		exit 1
	fi
	local func="$1"


	local operator="$2"
	local accepted_operators=( "==" ">" )
	local accepted_operator
	local inside=0
	for accepted_operator in "${accepted_operators[@]}"; do
		if [[ "$accepted_operator" == "$operator" ]]; then
			inside=1
		fi
	done
	if ! [[ $inside -eq 1 ]]; then
		output-failure "assert-correct-argument-count: \"$operator\" not a valid operator( one of: ${accepted_operators[*]})"
		exit 1
	fi
	local argcount="$3"
	local positive_num_re="^[0-9]+$"
	if ! [[ $argcount =~ $positive_num_re ]]; then
		output-failure "assert-correct-argument-count: \"$argcount\" not a valid positive integer"
		exit 1
	fi

	shift 3

	if  ( [[ "$operator" == ">"  ]] &&  ! [[ $# -gt $argcount ]] ) || \
	    ( [[ "$operator" == "==" ]] &&  ! [[ $# -eq $argcount ]] ) ; then
		output-failure "${func}: invalid argument count($# !${operator} $argcount)"
		exit 1
	fi
}






function show () {
	# extension of the program's main function for show options.
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-correct-argument-count "show" ">" 0 "$@"
	declare -A items=()
	
	while ! [[ $# -eq 0 ]]; do
		case $1 in
			authors)
				shift
				show-authors "$@"
				output-items
				exit 0
				;;
			playlists)
				shift
				show-playlists "$@"
				output-items
				exit 0
				;;
			mp3s)
				shift
				show-mp3s "$@"
				output-items
				exit 0
				;;
			author)
				shift
				show-author "$@"
				output-items
				exit 0
				;;
			playlist)
				shift
				show-playlist "$@"
				output-items
				exit 1
				;;
			*)
				output-failure "unrecognised show option:\"$1\""
				exit 1
				;;
		esac
	done
}

function output-items () {
	# output every item in the global items associative array
	# return to execution flow on success, exit on failure
		# success -> items were outputted
		# failure -> function arguments were given
	# no arguments
	# this function should be found after show functions in the show man function.
	assert-correct-argument-count "output-items" "==" 0 "$@"
	local item 
	for item in "${!items[@]}"; do
		if [[ ${items["$item"]} -eq 1 ]] ; then
			echo -e "\t$item"
		else
			echo -e "\t$item \t[${items[$item]}]"
		fi
	done
}

function show-playlist () {
	# add every playlist entry to items
	# return code on execution on success , exit 1 on failure
		# success: all entries added to items
		# failure:
			# wrong argument count
			# playlist directory no exists / unreadable
			# playlist not readable
			# mp3_directory not readable
			# mp3_directory empty
			# entry in playlist not valid, not to be deleted
	# 1 argument: playlist filename(basename'd)
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-correct-argument-count "show-playlist" "==" 1 "$@"
	local playlist="$1"
	is-file-readable "$playlist_directory"
	is-directory-not-empty "$playlist_directory"

	local playlist_path="${playlist_directory}${playlist}"
	is-file-readable "$playlist_path"
	
	is-file-readable "$mp3_directory"
	is-directory-not-empty "$mp3_directory"
	while read -u 69 entry; do
		if ! is-string-valid-mp3 "$entry"; then
			output-failure "\"$entry\" is not a valid mp3 file"
			if ! is-confirmed "Delete \"$entry\" from \"$playlist\""; then
				exit 1
			fi
			output-info "this functionality was not implemented yet"
		fi
		add-item "$entry"
	done 69<"$playlist_path"
}

function is-string-valid-mp3 () {
	# check if given string is a valid mp3 file
	# return 0 if is, return 1 if is not, exit 1
		# success: file was able to be checked for validity
		# failure:
			# mp3 directory not readable
			# mp3 directory empty
	# 1 argument: string
	assert-correct-argument-count "is-string-valid-mp3" "==" 1 "$@"
	local string="$1"
	is-file-readable "$mp3_directory"
	is-directory-not-empty "$mp3_directory"

	local filename
	for file in "$mp3_directory"*; do
		file="$( basename "$file" )" # remove string directories suffix
		if [[ "$file" == "$string" ]]; then
			return 0
		fi
	done
	return 1
}

function is-confirmed () {
	# get user yes, no input to make simple script decisions
	# return 0 if confirmed, return 1 if rejected, exit 1 on error
		# failures: wrong arg count
	# 1 argument: string prompt to display
	assert-correct-argument-count "is-confirmed" "==" 1 "$@"
	local prompt="$1"

	local confirmation=( "y" "ye" "yes" "Y" "Ye" "Yes" "YE" "YES" )
	local rejection=("n" "no" "N" "No" "NO" )
	while : ; do
		local user
		output-question "$prompt"
		read -p ":" user
		local option
		for option in "${confirmation[@]}"; do
			if [[ "$option" == "$user" ]]; then
				return 0
			fi
		done
		for option in "${rejection[@]}"; do
			if [[ "$option" == "$user" ]]; then
				return 1
			fi
		done
		output-info "Invalid user input: \"$user\""
	done
}



function show-author () {
	# add every mp3 file name the <author> is author of to items
	# return execution flow on success, exit 1 on failure
		# succcess: all files were looped through and added to items accordingly
		# failure: 
			# mp3 directory not readable, 
			# mp3 directory empty, 
			# failed to add/increment author in items
	# implementation of playlist show author <author>
	# 1 argument: the name of the author
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-correct-argument-count "show-author" "==" 1 "$@"
	
	local target_author="$1"
	
	is-file-readable "$mp3_directory"
	
	is-directory-not-empty "$mp3_directory"

	local file
	for file in "$mp3_directory"*; do
		local filename="$(basename "$file")"
		local mp3name="$(get-from-filename "$filename" "mp3")"
		local authors="$(get-from-filename "$filename" "authors")" 	# split from full filename
		authors="$(divide-authors "$authors")" 				# divide from ", " to "|"
		IFS='|' read -ra authors <<< "$authors"				# split with '|'
		for author in "${authors[@]}"; do
			if [[ "$author" == "$target_author" ]]; then
				add-item "$mp3name"
			fi
		done
	done
}

function show-authors () {
	# add every author in mp3 directory to items with their respective number of "author'ed" files
	# return execution flow on success, exit 1 on failure
		# succcess: all files were looped through and added to items accordingly
		# failure: 
			# mp3 directory not readable, 
			# mp3 directory empty, 
			# failed to add/increment author in items
	# implementation of playlist show authors
	# no arguments

	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-correct-argument-count "show-authors" "==" 0 "$@"
	is-file-readable "$mp3_directory"

	is-directory-not-empty "$mp3_directory"
	local file
	for file in "$mp3_directory"*; do
		local filename="$(basename "$file")"
		local mp3name="$(get-from-filename "$filename" "mp3")"
		local authors="$(get-from-filename "$filename" "authors")" 	# split from full filename
		authors="$(divide-authors "$authors")" 				# divide from ", " to "|"
		IFS='|' read -ra authors <<< "$authors"				# split with '|'
		for author in "${authors[@]}"; do
			add-item "$author"
		done

	done
}

function show-mp3s () {
	# adds every mp3 file to items
	# return execution flow on success, exit 1 on failure
		# success: all files were looped and added to items
		# failures:
			# wrong arg count
			# arg not in ["all", "used", "unused"]
			# mp3 directory not readable
			# mp3 directory empty
			# is-mp3-used fail
	# 1 argument: type of mp3: ["all", "used", "unused"]
	# implementation of playlister show mp3 <type>

	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-correct-argument-count "show-mp3s" "==" 1 "$@"
	local argument="$1"
	
	if ! (  [[ "$argument" == "all" ]] 	|| \
		[[ "$argument" == "used" ]] 	|| \
		[[ "$argument" == "unused" ]] 	); then
		output-failure "invalid show-mp3 argument:\"$argument\""
		exit 1
	fi
	
	is-file-readable "$mp3_directory"
	is-directory-not-empty "$mp3_directory"
	local file
	for file in "${mp3_directory}"*; do
		filename="$(basename "$file" )"

		if [[ "$argument" == "all" ]]; then
			add-item "$filename"

		elif [[ "$argument" == "used" ]]; then
			if is-mp3-used "$filename"; then
				add-item "$filename"
			fi

		else #unused
			if ! is-mp3-used "$filename"; then
				add-item "$filename"
			fi
		fi
	done
}

function is-mp3-used () {
	# checks if mp3 file is entry in a playlist
	# return int status as value, exit 1 on error
		# success: return status
			# 0 -> mp3 is used
			# 1 -> mp3 is not used
		# failure:
			# wrong arg count
			# playlist directory not readable
			# playlist directory empty
			# playlist file not readable
	# 1 argument: filename to be checked (previously basename'd!)
	# used in show-mp3 with mp3 type distinctions
	assert-correct-argument-count "is-mp3-used" "==" 1 "$@"
	local filename="$1"
	
	is-file-readable "$playlist_directory"

	is-directory-not-empty "$playlist_directory"

	local playlist
	for playlist in "${playlist_directory}"* ; do
		is-file-readable "$playlist"
		local line
		while read line; do
			if [[ "$line" == "$filename" ]]; then
				return 0
			fi
		done <"$playlist"
	done
	return 1
}

function show-playlists () {
	# add every playlist to items
	# return execution flow if success, exit 1 if failure
		# success: all playlists added to items
		# failure:
			# wrong arg count
			# playlist directory unreadable
			# playlist directory empty
			# add-item exits
	# no arguments
	# implementation of playlister show playlists

	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-correct-argument-count "show-playlists" "==" 0 "$@"
	is-file-readable "$playlist_directory"

	is-directory-not-empty "$playlist_directory"
	for file in "${playlist_directory}"* ; do
		local filename="$(basename "$file")"
		add-item "$filename"
	done
}

function is-item-inside-items () {
	assert-correct-argument-count "is-item-inside-items" "==" 1 "$@"
	local argument="$1"
	local item
	for item in "${!items[@]}"; do
		if [[ "$argument" == "$item" ]]; then
			return 0
		fi 
	done
	return 1
}

function get-from-filename () {
	
	assert-correct-argument-count "get-from-filename" "==" 2 "$@"
	
	local filename="$1"
	local option="$2"
	if ! ( [[ "$option" == "mp3" ]] || [[ "$option" == "authors" ]] ) ; then
		output-failure "invalid get-from-filename option:\"$option\""
		exit 1
	fi
	
	local separator=" - "
	local tmp=${filename//"$separator"/$'\2'}
	local authors
	local mp3
	IFS=$'\2' read authors mp3 <<< "$tmp"
	
	if [[ "$option" == "authors" ]]; then
		echo "$authors"
	else
		echo "$mp3"
	fi
}

function divide-authors (){
	assert-correct-argument-count "divide-authors" "==" 1 "$@"
	if ! [[ $# -eq 1 ]]; then
		output-failure "invalid divide-authors argument count (must be ==1)"
		exit 1
	fi
	local authors_string="$1"
	local separator=", "
	local authors=${authors_string//"$separator"/'|'}
	echo "$authors"
	
}

function add-item () {
	# add string item to items with initalized count, or if already exists: increase counter.
	# return to execution flow on success, exit on failure
		# success -> item added 
		# failure -> invalid argument count
	# 1 argument: string item to be added 
	assert-correct-argument-count "add-item" "==" 1 "$@"
	local new_item="$1"
	if is-item-inside-items "$new_item"; then
		items["$new_item"]=$(( ${items["$new_item"]} + 1 ))
	else
		items["$new_item"]=$(( 1 ))
	fi
}

function config () {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-correct-argument-count "config" ">" 0 "$@"

	declare -A items=()

	while [[ "$#" -gt 0 ]]; do
		case $1 in
			configure)
				shift
				config-configure "$@"
				exit 0
				;;
			list)
				shift
				read-config-if-exists
				config-list "$@"
				output-items
				exit 0
				;;
			get)
				shift
				read-config-if-exists
				config-get "$@"
				output-items
				exit 0
				;;
			set)	
				shift
				read-config-if-exists
				config-set "$@"
				output-items
				exit 0
				;;
			*)
				output-failure "unrecognised config option:\"$1\""
				exit 1
				;;
		esac
	done
}
function config-configure () {

	directory-config "$main_directory"
	
	file-configure "$help_file" "currentdir"
	
	file-configure "$config_file" "backup" "makenew"
	
	if read-config ; then
		output-success "$(basename "$config_file") read"
	else
		output-failure "$(basename "$config_file") failed to read"
		exit 1
	fi
	
	directory-config "$mp3_directory"

	directory-config "$playlist_directory"
}

function config-list () {
	assert-correct-argument-count "config-list" "==" 0 "$@"

	for configuration in "${!configs[@]}"; do
		# i do not need to check for validity of $configuration here
		# for $configuration is fetched directly from $configs
		add-item "	$configuration	-> 	${configs[$configuration]} "
	done
}

function config-get () {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-correct-argument-count "config-get" "==" 1 "$@"
	local argument="$1"
	if ! is-valid-config "$argument" ; then
		output-failure "not a valid configuration: \"$argument\""
		return 1
	fi
	get-config "$argument"
}

function config-set () {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-correct-argument-count "config-set" "==" 2 "$@"
	local config_file_name="$( basename "$config_file" )"
	
	if ! [[ -w "$config_file" ]]; then
		output-failure "$config_file_name is not writable"
		exit 1
	fi
	
	> "$tmp_file"
	if ! [[ $? -eq 0 ]]; then
		output-failure "failed to create a file in /tmp"
		exit 1
	fi
	
	local argument="$1"
	if ! is-valid-config-mutable "$argument"; then
		output-failure "not a valid mutable configuration:\"$argument\""
		exit 1
	fi
	
	if ! change-configs-to-tmp "$@"; then
		output-failure "failed to change configs"
		exit 1
	fi
	
	cp "$tmp_file" "$config_file"
	if ! [[ $? -eq 0 ]]; then
		output-file "failed to overwrite $config_file_name with tmp file"
		exit 1
	fi
}

function directory-config () {
	# configure directory creation for eg. config configure
	# return to execution on success, exit 1 on failure
		# failures:
			# could not create directory
			# directory is a file rather than a directory
			# directory is not readable
	# arguments:
		# full path of the directory
	assert-correct-argument-count "directory-config" "==" 1 "$@"
	local dir="$1"
	local dirname="$(basename "$dir" )"
	if ! is-file-exists "$dir"; then
		output-info "\"$dirname\" does not exist"
		mkdir "$dir"
		if ! [[ $? -eq 0 ]]; then
			output-failure "\"$dirname\" failed to create"
			exit 1
		fi
		output-info "\"$dirname\" created"
	fi
	output-info "\"$dirname\" exists"

	if ! is-file-directory "$dir"; then
		output-failure "\"$dirname\" is not a directory"
		exit 1
	fi
	output-info "\"$dirname\" is a directory"

	if ! is-file-readable "$dir"; then
		output-failure "\"$dirname\" is not readable"
		exit 1
	fi
	output-info "\"$dirname\" is readable"
}


function file-configure () {
	assert-correct-argument-count "file-configure" ">" 1 "$@"
	local file="$1"
	local filename="$( basename "$file" )"
	local backup=1
	local currentdir=1
	local makenew=1
	shift
	while [[ "$#" -ne 0 ]]; do
		case $1 in 
			"backup")
				backup=1
				shift
				;;
			"currentdir")
				currentdir=1
				shift
				;;
			"makenew")
				makenew=1
				shift
				;;
			*)
				output-failure "unrecognised file-configure option:\"$1\""
				return 1
				;;
		esac
	done

	if is-file-exists "$file"; then
		output-info "$filename exists"
		return 0
	fi
	output-info "$filename does not exist"
	
	if [[ $backup -eq 1 ]]; then
		local fileback="${file}${backup_ext}"
		if is-file-exists "$fileback"; then
			cp "$fileback" "$file"
			if [[ $? -eq 0 ]]; then
				output-success "$filename created from backup"
				return
			fi
			output-info "$filename failed to create from backup"
		fi
		output-info "$filename does not have a backup"
	fi

	if [[ $currentdir -eq 1 ]]; then
		if is-file-exists "$filename"; then
			cp "$filename" "$file"
			if [[ $? -eq 0 ]]; then
				output-success "$filename created from current directory"
				return
			fi
			output-info "$filename failed to create from current directory"
		fi
		output-info "$filename not found in current directory"
	fi

	if [[ $makenew -eq 1 ]]; then
		touch "$file"
		if [[ $? -eq 0 ]]; then
			output-success "$filename created blank"
			return 0
		fi
		output-failure "$filename failed to create blank"
	fi
	
	output-failure "$filename configuration failed"
	exit 1 
}

function read-config () {
	is-file-readable "$config_file"
	while read line ; do
		local argument="$(echo "$line" | cut -d "=" -f 1)"
		case "$argument" in
			"mp3_directory")
				local value="$(echo "$line" | cut -d "=" -f 2)"
				mp3_directory="$value"
				configs["mp3_directory"]="$value"
				;;
			"playlist_directory")
				local value="$(echo "$line" | cut -d "=" -f 2)"
				playlist_directory="$value"
				configs["playlist_directory"]="$value"
				;;
			*)
				output-failure "not valid user config: \"$argument\""
				return 1
				;;
		esac
	done < "$config_file"
}

function read-config-if-exists () {
	
	local config_file_name="$(basename "$config_file")"
	if ! [[ -a "$config_file" ]]; then
		output-failure "$config_file_name does not exist"
		exit 1
	fi

	if ! read-config; then
		output-failure "$config_file_name failed to read"
		exit 1
	fi
}

function is-valid-config (){
	assert-correct-argument-count "is-valid-config" "==" 1 "$@"
	local argument="$1"
	local configuration
	for configuration in "${!configs[@]}"; do
		if [[ "$configuration" == "$argument" ]]; then
			return 0
		fi
	done
	return 1
}

function change-configs-to-tmp () {
	assert-correct-argument-count "change-configs-to-tmp" "==" 2 "$@"
	local config="$1"
	local value="$2"
	local found="no"
	local line
	while read line; do
		if [[ "$(echo "$line" | cut -d "=" -f 1)" == "$config" ]]; then
			echo "${config}=${value}" >> "$tmp_file"
			found="yes"
		else
			echo "$line" >> "$tmp_file"
		fi
	done < "$config_file"
	if [[ "$found" == "no" ]]; then
		echo "${config}=${value}" >> "$tmp_file"
	fi
}

function is-valid-config-mutable () {
	assert-correct-argument-count "is-valid-config-mutable" "==" 1 "$@"
	local argument="$1"
	local configuration
	for configuration in "${configs_mutable[@]}"; do
		if [[ "$argument" == "$configuration" ]]; then
			return 0
		fi
	done
	return 1
	
}


function get-config () {
	assert-correct-argument-count "get-config" "==" 1 "$@"
	local argument="$1"
    	output-info "	$argument	-> 	${configs[$argument]} "
}

function is-directory-not-empty () {
	# check if directory is empty
	# return to execution flow on success, exit on failure
		# success -> directory is not empty 
		# failure -> directory is empty
	# 1 argument: the directory
	assert-correct-argument-count "is-directory-not-empty" "==" 1 "$@"
	local directory="$1"

	if ! find "$directory" -mindepth 1 -maxdepth 1 | read; then
		output-failure "$directory is empty"
		exit 1
	fi
}

function is-file-readable () {
	# check if file is readable
		# success -> file is readable
		# failure -> file is not readable
	# return to execution flow on success, exit on failure
	# 1 argument: the file
	assert-correct-argument-count "is-file-readable" "==" 1 "$@"
	local file="$1"
	file="${file%/}"	# trim slash if file given for when the file given is a directory.
	if ! [[ -r "$file" ]]; then
		output-failure "$file not readable"
		exit 1
	fi
}

function is-file-exists () {
	# determine if file exists
	# return 0 if file exists, return 1 if file does not exist
	# 1 argument:
		# the full path to the file
	assert-correct-argument-count "is-file-exists" "==" 1 "$@"
	local file="$1"
	if [[ -e "$file" ]]; then
		return 0
	fi
	return 1
}

function is-file-directory () {
	# determine if file exists and is a directory
	# return 0 if file exists and is a directory, return 1 if not exists or is not a directory
	# 1 argument:
		# the full path to the file
	assert-correct-argument-count "is-file-directory" "==" 1 "$@"
	local file="$1"
	if [[ -d "$file" ]]; then
		return 0
	fi
	return 1
}

function output-success () {
	# unifying user success output
	# 1 argument: the string to output
	assert-correct-argument-count "output-success" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local green="\e[1;32m"
	>&2 echo -e "${white}(${green}+${white}) ${output}."
}

function output-failure () {
	# unifying user failure output
	# 1 argument: the string to output
	assert-correct-argument-count "output-failure" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local red="\e[1;31m"
	>&2 echo -e "${white}(${red}-${white}) ${output}!"
}

function output-info () {
	# unfying user informative output
	# 1 argument: the string to output
	assert-correct-argument-count "output-info" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local yellow="\e[1;33m"
	>&2 echo -e "${white}(${yellow}*${white}) ${output}."
}

function output-question () {
	# unifying user prompt output (used in is-confirmed)
	# 1 argument: the string to output
	assert-correct-argument-count "output-question" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local blue="\e[1;34m"
	>&2 echo -e "${white}(${blue}?${white}) ${output}?"
}

main "$@"
