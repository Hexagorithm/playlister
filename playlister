#!/bin/bash

# Hardcoded defaults
#	Immutable
main_directory="$HOME/.playlister/"
config_file="${main_directory}playlister.conf"
help_file="${main_directory}playlister.help"
playlist_ext=".plst"
mp3_ext=".mp3"
backup_ext=".bak"
#	Mutable
playlist_directory="${main_directory}playlists/"
mp3_directory="${main_directory}mp3s/"

declare -A config2value=( 
	["main_directory"]="$main_directory" \
	["config_file"]="$config_file" \
	["help_file"]="$help_file" \
	["playlist_directory"]="$playlist_directory" \
	["mp3_directory"]="$mp3_directory" \
)

declare -a configs_all=(
	"main_directory" 	\
	"config_file" 		\
	"help_file" 		\
	"playlist_directory"	\
	"mp3_directory"
)

declare -a configs_mutable=(
	"mp3_directory" \
	"playlist_directory"
)

function main () {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "main" ">" 0 "$@"
	while [[ "$#" -gt 0 ]]; do
		case $1 in 
			config)
				shift
				config "$@"
				exit 0
				;;
			show)
				shift
				assert-file-exists "$config_file"
				assert-file-readable "$config_file"
				read-config
				show "$@"
				exit 0
				;;
			playlist)
				shift
				assert-file-exists "$config_file"
				assert-file-readable "$config_file"
				read-config
				playlist "$@"
				exit 1
				;;

			*)
				output-failure "unrecognised option:\"$1\""
				shift
				exit 1
				;;
		esac
	done
}

function assert-arg-count () {
	# Check if function given correct arg amount.
	# return execution flow on success, exit 1 on failure
		# success: correct arg count given to function
		# failure:
			# wrong arg count given to assert-corr...
			# invalid operator given
			# assertion failed
	# Arguments:
		# func 				-> name of function (needed for failure output)
		# operator 			-> keyword together with argcount specifying the argument count
		# argcount 			-> a point of refrence for arguments expected
		# optional arguments... 	-> arguments given originally to func
	# the func arguments need to be inputted with [@] (protect from "My Argument" arguments with [*])
	if ! [[ $# -ge 3 ]]; then
		output-failure "assert-arg-count: invalid argument count(must be >= 3, but {$#} were given)"
		exit 1
	fi
	local func="$1"


	local operator="$2"
	local accepted_operators=( "==" ">" "<" )
	local accepted_operator
	local inside=0
	for accepted_operator in "${accepted_operators[@]}"; do
		if [[ "$accepted_operator" == "$operator" ]]; then
			inside=1
		fi
	done
	if ! [[ $inside -eq 1 ]]; then
		output-failure "assert-arg-count: \"$operator\" not a valid operator( one of: ${accepted_operators[*]})"
		exit 1
	fi
	local argcount="$3"
	local positive_num_re="^[0-9]+$"
	if ! [[ $argcount =~ $positive_num_re ]]; then
		output-failure "assert-arg-count: \"$argcount\" not a valid positive integer"
		exit 1
	fi

	shift 3

	if  ( [[ "$operator" == ">"  ]] &&  ! [[ $# -gt $argcount ]] ) || \
	    ( [[ "$operator" == "==" ]] &&  ! [[ $# -eq $argcount ]] ) || \
	    ( [[ "$operator" == "<"  ]] &&  ! [[ $# -lt $argcount ]] ) ; then

		output-failure "${func}: invalid argument count($# !${operator} $argcount)"
		exit 1
	fi
}



function playlist() {
	assert-arg-count "playlist" ">" 0 "$@"
	declare -A items=()
	while ! [[ $# -eq 0 ]]; do
		case $1 in 
			add)
				shift 
				add "$@"
				output-items
				exit 1	
				;;
			*)
				output-failure "\"$1\" unrecognized playlist option"
				exit 1
				;;
		esac

	done
}

function add() {
	# to playlist, add every mp3 file that is valid and not an entry, also add tme to items
	# exit 1 on failure
		# failures:
			# wrong arg count
			# playlist directory not readable or empty
			# playlist file invalid, not readable, not writable
			# invalid mp3 file
	# 2 arguments;
		# 1) 	basenamed playlist filename
		# 2..)  basenamed mp3files to add
	assert-arg-count "add" ">" 1 "$@"
	local playlistname="$1"
	shift
	declare -A items=()

	assert-file-readable "$playlist_directory"
	assert-directory-not-empty "$playlist_directory"
	if ! is-string-valid-playlist "$playlistname"; then
		output-failure "\"$playlistname\" invalid playlist"
		exit 1
	fi

	local playlist="${playlist_directory}${playlistname}"

	assert-file-readable "$playlist"
	assert-file-writable "$playlist"

	while ! [[ $# -eq 0 ]]; do
		local entry="$1"
		shift
		if ! is-string-valid-mp3 "$entry"; then
			output-failure "\"$entry\" invalid mp3 file"
			continue
		fi
		local inside=0
		while read line; do
			if [[ "$entry" == "$line" ]]; then
				inside=1
			fi
		done <"$playlist"
		if [[ $inside -eq 1 ]]; then
			output-failure "\"$entry\" in \"$playlistname\""
			continue
		fi
		echo "$entry" >> "$playlist"
		add-item "$entry"
	done
}


function show () {
	# extension of the program's main function for show options.
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "show" ">" 0 "$@"
	declare -A items=()
	
	while ! [[ $# -eq 0 ]]; do
		case $1 in
			authors)
				shift
				assert-arg-count "show-authors" "<" 2 "$@"
				if 	[[ $# -eq 0 ]]; then
					show-authors "$@"
				elif 	[[ $# -eq 1 ]]; then
					show-authors-of-mp3 "$@"
				fi
				output-items
				exit 0
				;;
			playlists)
				shift
				show-playlists "$@"
				output-items
				exit 0
				;;
			mp3s)
				shift
				show-mp3s "$@"
				output-items
				exit 0
				;;
			author)
				shift
				show-author "$@"
				output-items
				exit 0
				;;
			playlist)
				shift
				show-playlist "$@"
				output-items
				exit 0
				;;
			mp3)
				shift
				show-mp3 "$@"
				output-items
				exit 0
				;;
			*)
				output-failure "unrecognised show option:\"$1\""
				exit 1
				;;
		esac
	done
}

function output-items () {
	# output every item in the global items associative array
	# return to execution flow on success, exit on failure
		# success -> items were outputted
		# failure -> function arguments were given
	# no arguments
	# this function should be found after show functions in the show man function.
	assert-arg-count "output-items" "==" 0 "$@"
	local item 
	for item in "${!items[@]}"; do
		if [[ ${items["$item"]} -eq 1 ]] ; then
			echo -e "\t$item"
		else
			echo -e "\t$item \t[${items[$item]}]"
		fi
	done
}

function show-mp3 () {
	# add every playlist to items, if playlist has $mp3name
	# return execution on success, ext 1 on failure
		# failure:
			# wrong arg count
			# argument not a  valid mp3 file
			# playlist directory not readable or is empty
			# a playlist file is not readable
	# 1 argument:
		# basenamed filename of the mp3 file
	assert-arg-count "show-mp3" "==" 1 "$@"

	local mp3name="$1"
	if ! is-string-valid-mp3 "$mp3name"; then
		output-failure "\"$mp3name\" not a valid mp3 file"
		exit 1
	fi

	assert-file-readable "$playlist_directory"
	assert-directory-not-empty "$playlist_directory"		

	for file in "${playlist_directory}"*; do
		local filename="$(basename "$file" )"
		assert-file-readable "$file"
		while read line; do 
			if [[ "$line" == "$mp3name" ]]; then
				add-item "$filename"
			fi
		done < "$file"
	done
}

function show-playlist () {
	# add every playlist entry to items
	# return code on execution on success , exit 1 on failure
		# success: all entries added to items
		# failure:
			# wrong argument count
			# playlist directory no exists / unreadable
			# playlist not readable
			# mp3_directory not readable
			# mp3_directory empty
			# entry in playlist not valid, not to be deleted
	# 1 argument: playlist filename(basename'd)
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "show-playlist" "==" 1 "$@"
	local playlist="$1"
	assert-file-readable "$playlist_directory"
	assert-directory-not-empty "$playlist_directory"

	local playlist_path="${playlist_directory}${playlist}"
	assert-file-exists "$playlist_path"
	assert-file-readable "$playlist_path"

	
	assert-file-readable "$mp3_directory"
	assert-directory-not-empty "$mp3_directory"
	while IFS= read -ru 69 entry; do
		add-item "$entry"
	done 69<"$playlist_path"
}

function is-string-valid-mp3 () {
	# check if given string is a valid mp3 file
	# return 0 if is, return 1 if is not, exit 1
		# success: file was able to be checked for validity
		# failure:
			# mp3 directory not readable
			# mp3 directory empty
	# 1 argument: string
	assert-arg-count "is-string-valid-mp3" "==" 1 "$@"
	local string="$1"
	assert-file-readable "$mp3_directory"
	assert-directory-not-empty "$mp3_directory"

	local filename
	for file in "$mp3_directory"*; do
		file="$( basename "$file" )" # remove string directories suffix
		if [[ "$file" == "$string" ]]; then
			return 0
		fi
	done
	return 1
}

function is-string-valid-playlist () {
	# check if given string is a valid playlist 
	# return 0 if is, return 1 if is not, exit 1
		# success: file was able to be checked for validity
		# failure:
			# playlist directory not readable
			# playlist directory empty
	# 1 argument: basenamed name of the playlist
	assert-arg-count "is-string-valid-playlist" "==" 1 "$@"
	local target_filename="$1"
	assert-file-readable "$playlist_directory"
	assert-directory-not-empty "$playlist_directory"

	local file
	for file in "$playlist_directory"* ; do 
		local filename="$(basename "$file")"
		if [[ "$filename" == "$target_filename" ]]; then
			return 0
		fi
	done
	return 1
}

function is-confirmed () {
	# get user yes, no input to make simple script decisions
	# return 0 if confirmed, return 1 if rejected, exit 1 on error
		# failures: wrong arg count
	# 1 argument: string prompt to display
	assert-arg-count "is-confirmed" "==" 1 "$@"
	local prompt="$1"

	local confirmation=( "y" "ye" "yes" "Y" "Ye" "Yes" "YE" "YES" )
	local rejection=("n" "no" "N" "No" "NO" )
	while : ; do
		local user
		output-question "$prompt"
		read -p ":" user
		local option
		for option in "${confirmation[@]}"; do
			if [[ "$option" == "$user" ]]; then
				return 0
			fi
		done
		for option in "${rejection[@]}"; do
			if [[ "$option" == "$user" ]]; then
				return 1
			fi
		done
		output-info "Invalid user input: \"$user\""
	done
}



function show-author () {
	# add every mp3 file name the <author> is author of to items
	# return execution flow on success, exit 1 on failure
		# succcess: all files were looped through and added to items accordingly
		# failure: 
			# mp3 directory not readable, 
			# mp3 directory empty, 
			# failed to add/increment author in items
	# implementation of playlist show author <author>
	# 1 argument: the name of the author
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "show-author" "==" 1 "$@"
	
	local target_author="$1"
	
	assert-file-readable "$mp3_directory"
	
	assert-directory-not-empty "$mp3_directory"

	local file
	for file in "$mp3_directory"*; do
		local filename="$(basename "$file")"
		local mp3name="$(get-from-filename "$filename" "mp3")"
		local authors="$(get-from-filename "$filename" "authors")" 	# split from full filename
		authors="$(divide-authors "$authors")" 				# divide from ", " to "|"
		IFS='|' read -ra authors <<< "$authors"				# split with '|'
		for author in "${authors[@]}"; do
			if [[ "$author" == "$target_author" ]]; then
				add-item "$mp3name"
			fi
		done
	done
}

function show-authors () {
	# add every author in mp3 directory to items with their respective number of "author'ed" files
	# return execution flow on success, exit 1 on failure
		# succcess: all files were looped through and added to items accordingly
		# failure: 
			# mp3 directory not readable, 
			# mp3 directory empty, 
			# failed to add/increment author in items
	# implementation of playlist show authors
	# no arguments

	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "show-authors" "==" 0 "$@"
	assert-file-readable "$mp3_directory"

	assert-directory-not-empty "$mp3_directory"
	local file
	for file in "$mp3_directory"*; do
		local filename="$(basename "$file")"
		local mp3name="$(get-from-filename "$filename" "mp3")"
		local authors="$(get-from-filename "$filename" "authors")" 	# split from full filename
		authors="$(divide-authors "$authors")" 				# divide from ", " to "|"
		IFS='|' read -ra authors <<< "$authors"				# split with '|'
		for author in "${authors[@]}"; do
			add-item "$author"
		done

	done
}

function show-authors-of-mp3 () {
	# adds every author in mp3 directory that is author of mp3 file which name is <mp3>
	# return execution flow n success, exit 1 on failure
		# failure:
			# wrong arg count
			# mp3 directory not readable
	# 1 argument:
		# the target mp3 file name (without authors, with mp3 extension)
	assert-arg-count "show-authors-of-mp3" "==" 1 "$@"
	local target_mp3name="$1"

	assert-file-readable "$mp3_directory"
	assert-directory-not-empty "$mp3_directory"
	for file in "$mp3_directory"*; do
		local filename="$(basename "$file" )"
		local mp3name="$(get-from-filename "$filename" "mp3")"
		if [[ "$mp3name" == "$target_mp3name" ]]; then
			local authors="$(get-from-filename "$filename" "authors")"
			authors="$(divide-authors "$authors")"
			IFS='|' read -ra authors <<< "$authors"
			for author in "${authors[@]}"; do
				add-item "$author"
			done
		fi

	done
}

function show-mp3s () {
	# adds every mp3 file to items
	# return execution flow on success, exit 1 on failure
		# success: all files were looped and added to items
		# failures:
			# wrong arg count
			# arg not in ["all", "used", "unused"]
			# mp3 directory not readable
			# mp3 directory empty
			# is-mp3-used fail
	# 1 argument: type of mp3: ["all", "used", "unused"]
	# implementation of playlister show mp3 <type>

	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "show-mp3s" "==" 1 "$@"
	local argument="$1"
	
	if ! (  [[ "$argument" == "all" ]] 	|| \
		[[ "$argument" == "used" ]] 	|| \
		[[ "$argument" == "unused" ]] 	); then
		output-failure "invalid show-mp3 argument:\"$argument\""
		exit 1
	fi
	
	assert-file-readable "$mp3_directory"
	assert-directory-not-empty "$mp3_directory"
	local file
	for file in "${mp3_directory}"*; do
		filename="$(basename "$file" )"

		if [[ "$argument" == "all" ]]; then
			add-item "$filename"

		elif [[ "$argument" == "used" ]]; then
			if is-mp3-used "$filename"; then
				add-item "$filename"
			fi

		else #unused
			if ! is-mp3-used "$filename"; then
				add-item "$filename"
			fi
		fi
	done
}

function is-mp3-used () {
	# checks if mp3 file is entry in a playlist
	# return int status as value, exit 1 on error
		# success: return status
			# 0 -> mp3 is used
			# 1 -> mp3 is not used
		# failure:
			# wrong arg count
			# playlist directory not readable
			# playlist directory empty
			# playlist file not readable
	# 1 argument: filename to be checked (previously basename'd!)
	# used in show-mp3 with mp3 type distinctions
	assert-arg-count "is-mp3-used" "==" 1 "$@"
	local filename="$1"
	
	assert-file-readable "$playlist_directory"

	assert-directory-not-empty "$playlist_directory"

	local playlist
	for playlist in "${playlist_directory}"* ; do
		assert-file-readable "$playlist"
		local line
		while read line; do
			if [[ "$line" == "$filename" ]]; then
				return 0
			fi
		done <"$playlist"
	done
	return 1
}

function show-playlists () {
	# add every playlist to items
	# return execution flow if success, exit 1 if failure
		# success: all playlists added to items
		# failure:
			# wrong arg count
			# playlist directory unreadable
			# playlist directory empty
			# add-item exits
	# no arguments
	# implementation of playlister show playlists

	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "show-playlists" "==" 0 "$@"
	assert-file-readable "$playlist_directory"

	assert-directory-not-empty "$playlist_directory"
	for file in "${playlist_directory}"* ; do
		local filename="$(basename "$file")"
		add-item "$filename"
	done
}

function is-item-inside-items () {
	assert-arg-count "is-item-inside-items" "==" 1 "$@"
	local argument="$1"
	local item
	for item in "${!items[@]}"; do
		if [[ "$argument" == "$item" ]]; then
			return 0
		fi 
	done
	return 1
}

function get-from-filename () {
	
	assert-arg-count "get-from-filename" "==" 2 "$@"
	
	local filename="$1"
	local option="$2"
	if ! ( [[ "$option" == "mp3" ]] || [[ "$option" == "authors" ]] ) ; then
		output-failure "invalid get-from-filename option:\"$option\""
		exit 1
	fi
	
	local separator=" - "
	local tmp=${filename//"$separator"/$'\2'}
	local authors
	local mp3
	IFS=$'\2' read authors mp3 <<< "$tmp"
	
	if [[ "$option" == "authors" ]]; then
		echo "$authors"
	else
		echo "$mp3"
	fi
}

function divide-authors (){
	assert-arg-count "divide-authors" "==" 1 "$@"
	if ! [[ $# -eq 1 ]]; then
		output-failure "invalid divide-authors argument count (must be ==1)"
		exit 1
	fi
	local authors_string="$1"
	local separator=", "
	local authors=${authors_string//"$separator"/'|'}
	echo "$authors"
	
}

function add-item () {
	# add string item to items with initalized count, or if already exists: increase counter.
	# return to execution flow on success, exit on failure
		# success -> item added 
		# failure -> invalid argument count
	# 1 argument: string item to be added 
	assert-arg-count "add-item" "==" 1 "$@"
	local new_item="$1"
	if is-item-inside-items "$new_item"; then
		items["$new_item"]=$(( ${items["$new_item"]} + 1 ))
	else
		items["$new_item"]=$(( 1 ))
	fi
}

function config () {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "config" ">" 0 "$@"

	declare -A items=()

	while [[ "$#" -gt 0 ]]; do
		case $1 in
			configure)
				shift
				config-configure "$@"
				exit 0
				;;
			list)
				shift
				assert-file-exists "$config_file"
				assert-file-readable "$config_file"
				read-config
				config-list "$@"
				output-items
				exit 0
				;;
			get)
				shift
				assert-file-exists "$config_file"
				assert-file-readable "$config_file"
				read-config
				config-get "$@"
				output-items
				exit 0
				;;
			set)	
				shift
				assert-file-exists "$config_file"
				assert-file-readable "$config_file"
				read-config
				config-set "$@"
				output-items
				exit 0
				;;
			*)
				output-failure "unrecognised config option:\"$1\""
				exit 1
				;;
		esac
	done
}
function config-configure () {
	
	directory-config "$main_directory"
	
	file-configure "$help_file" "currentdir"
	
	file-configure "$config_file" "backup" "makenew"
	
	if read-config ; then
		output-success "$(basename "$config_file") read"
	else
		output-failure "$(basename "$config_file") failed to read"
		exit 1
	fi
	
	directory-config "$mp3_directory"

	directory-config "$playlist_directory"
}

function config-list () {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "config-list" "==" 0 "$@"

	for configuration in "${!config2value[@]}"; do
		# i do not need to check for validity of $configuration here
		# for $configuration is fetched directly from $config2value
		add-item "	$configuration	-> 	${config2value[$configuration]} "
	done
}

function config-get () {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "config-get" "==" 1 "$@"
	local configuration="$1"
	assert-valid-config "$configuration" "all"
	add-item "	$configuration	-> 	${config2value[$configuration]} "
}

function config-set () {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "config-set" "==" 2 "$@"

	local configuration="$1"
	local newvalue="$2"
	assert-valid-config "$configuration" "mutable"

	assert-file-exists "$config_file"
	update-config-file "$configuration" "$newvalue"
}

function update-config-file () {
	assert-arg-count "update-config-file" "==" 2 "$@"
	local configuration="$1"
	local newvalue="$2"

	assert-file-readable "$config_file"
	assert-file-writable "$config_file"
	sed -i "/^${configuration}=/d" "$config_file"
	echo "${configuration}=${newvalue}" >> "$config_file"
}

function directory-config () {
	# configure directory creation for eg. config configure
	# return to execution on success, exit 1 on failure
		# failures:
			# could not create directory
			# directory is a file rather than a directory
			# directory is not readable
	# arguments:
		# full path of the directory
	assert-arg-count "directory-config" "==" 1 "$@"
	local dir="$1"
	local dirname="$(basename "$dir" )"
	if ! is-file-directory-exists "$dir"; then
		output-info "\"$dirname\" does not exist"
		# is-file-directory-exists will omit ${dir%/} 
		# but mkdir treats $dir and ${dir%/} the same
		# and will fail if ${dir%/} exists
		if is-file-exists "${dir%/}"; then
			output-failure "\"$dirname\" can't be created because \"${dir%/}\" file exists"
			exit 1
		fi
		mkdir "$dir"
		if ! [[ $? -eq 0 ]]; then
			output-failure "\"$dirname\" failed to create"
			exit 1
		fi
		output-info "\"$dirname\" created"
	fi
	output-info "\"$dirname\" exists"

	assert-file-directory "$dir"

	output-info "\"$dirname\" is a directory"

	assert-file-readable "$dir"

	output-info "\"$dirname\" is readable"
}


function file-configure () {
	assert-arg-count "file-configure" ">" 1 "$@"
	local file="$1"
	local filename="$( basename "$file" )"
	local backup=0
	local currentdir=0
	local makenew=0
	shift
	while [[ "$#" -ne 0 ]]; do
		case $1 in 
			"backup")
				backup=1
				shift
				;;
			"currentdir")
				currentdir=1
				shift
				;;
			"makenew")
				makenew=1
				shift
				;;
			*)
				output-failure "unrecognised file-configure option:\"$1\""
				return 1
				;;
		esac
	done

	if is-file-exists "$file"; then
		output-info "$filename exists"
		return 0
	fi
	output-info "$filename does not exist"
	
	if [[ $backup -eq 1 ]]; then
		local fileback="${file}${backup_ext}"
		if is-file-exists "$fileback"; then
			cp "$fileback" "$file"
			if [[ $? -eq 0 ]]; then
				output-success "$filename created from backup"
				return
			fi
			output-info "$filename failed to create from backup"
		fi
		output-info "$filename does not have a backup"
	fi

	if [[ $currentdir -eq 1 ]]; then
		if is-file-exists "$filename"; then
			cp "$filename" "$file"
			if [[ $? -eq 0 ]]; then
				output-success "$filename created from current directory"
				return
			fi
			output-info "$filename failed to create from current directory"
		fi
		output-info "$filename not found in current directory"
	fi

	if [[ $makenew -eq 1 ]]; then
		touch "$file"
		if [[ $? -eq 0 ]]; then
			output-success "$filename created blank"
			return 0
		fi
		output-failure "$filename failed to create blank"
	fi
	
	output-failure "$filename configuration failed"
	exit 1 
}

function read-config () {
	assert-file-readable "$config_file"
	while read line ; do
		local argument="$(echo "$line" | cut -d "=" -f 1)"
		case "$argument" in
			"mp3_directory")
				local value="$(echo "$line" | cut -d "=" -f 2)"
				mp3_directory="$value"
				config2value["mp3_directory"]="$value"
				;;
			"playlist_directory")
				local value="$(echo "$line" | cut -d "=" -f 2)"
				playlist_directory="$value"
				config2value["playlist_directory"]="$value"
				;;
			*)
				output-failure "not valid user config: \"$argument\""
				return 1
				;;
		esac
	done < "$config_file"
}

function assert-valid-config () {
	# check if config is valid
	# return to execution flow if config valid , exit 1 if otherwise
	# 2 arguments:
		# 1) configuration to be checked
		# 2) keyword for type of configuration ("all" "mutable")
	assert-arg-count "assert-valid-config" "==" 2 "$@"
	local configuration="$1"
	local keyword="$2"
	declare -a valid_keywords=( "all" "mutable" )
	local is_valid=0
	for valid_keyword in "${valid_keywords[@]}"; do
		if [[ "$valid_keyword" == "$keyword" ]]; then
			is_valid=1
		fi
	done
	if [[ $is_valid -eq 0 ]]; then
		output-failure "\"$keyword\" not a valid assert-valid-config keyword (must be in:\"${valid_keywords[*]}\")"
		exit 1
	fi

	declare -a valid_configurations=()
	if 	[[ "$keyword" == "all" ]]; then
		for item in "${configs_all[@]}"; do
			valid_configurations+=("$item")
		done

	elif 	[[ "$keyword" == "mutable" ]]; then
		for item in "${configs_mutable[@]}"; do
			valid_configurations+=("$item")
		done

	else
		output-failure "\"$keyword\"... What the fuck?"
		exit 1
	fi

	for valid_configuration in "${valid_configurations[@]}"; do
		if [[ "$configuration" == "$valid_configuration" ]]; then
			return
		fi
	done
	output-failure "\"${configuration}\" not a valid ${keyword} configuration"
	exit 1
}

function get-config () {
	assert-arg-count "get-config" "==" 1 "$@"
	local argument="$1"
    	output-info "	$argument	-> 	${config2value[$argument]} "
}

function assert-directory-not-empty () {
	# check if directory is empty
	# return to execution flow on success, exit on failure
		# success -> directory is not empty 
		# failure -> directory is empty
	# 1 argument: the directory
	assert-arg-count "assert-directory-not-empty" "==" 1 "$@"
	local directory="$1"

	if ! find "$directory" -mindepth 1 -maxdepth 1 | read; then
		output-failure "$directory is empty"
		exit 1
	fi
}

function assert-file-writable () {
	# check if file is writable
	# return to execution flow no success, exit on failure
	# 1 argument: 
		# full path to the file
	assert-arg-count "assert-file-writable" "==" 1 "$@"
	local file="$1"
	file="${file%/}"	# trim slash if file given for when the file given is a directory.
	if ! [[ -w "$file" ]]; then
		output-failure "$(basename "$file") not writable"
		exit 1
	fi

}

function assert-file-readable () {
	# check if file is readable
	# return to execution flow on success, exit on failure
		# success -> file is readable
		# failure -> file is not readable
	# 1 argument: the file
	assert-arg-count "assert-file-readable" "==" 1 "$@"
	local file="$1"
	file="${file%/}"	# trim slash if file given for when the file given is a directory.
	if ! [[ -r "$file" ]]; then
		output-failure "$(basename "$file") not readable"
		exit 1
	fi
}

function assert-file-exists (){
	# check for file existence
	# return execution flow if file exists, exit 1 otherwise
	# 1 argument:
		# the full path to the file
	assert-arg-count "assert-file-exists" "==" 1 "$@"
	local file="$1"
	if ! [[ -e "$file" ]]; then
		output-failure "$(basename "$file") does not exist"
		exit 1
	fi
}

function is-file-exists () {
	# determine if file exists
	# return 0 if file exists, return 1 if file does not exist
	# 1 argument:
		# the full path to the file
	assert-arg-count "is-file-exists" "==" 1 "$@"
	local file="$1"
	if [[ -e "$file" ]]; then
		return 0
	fi
	return 1
}

function is-file-directory-exists () {
	# determine if file exists and is a directory
	# return 0 if file exists and is a directory, return 0 otherwise
	# 1 argument:
		# the full path to the file
	assert-arg-count "is-file-directory-exists" "==" 1 "$@"
	local file="$1"
	if [[ -d "$file" ]]; then
		return 0
	fi
	return 1
}

function assert-file-directory () {
	# determine if file exists and is a directory
	# return execution flow on success, exit 1 on failure
	# 1 argument:
		# the full path to the file
	assert-arg-count "assert-file-directory" "==" 1 "$@"
	local file="$1"
	if ! [[ -d "$file" ]]; then
		output-failure "$(basename "$file") not a directory"
		exit 1
	fi
}

function output-success () {
	# unifying user success output
	# 1 argument: the string to output
	assert-arg-count "output-success" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local green="\e[1;32m"
	>&2 echo -e "${white}(${green}+${white}) ${output}."
}

function output-failure () {
	# unifying user failure output
	# 1 argument: the string to output
	assert-arg-count "output-failure" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local red="\e[1;31m"
	>&2 echo -e "${white}(${red}-${white}) ${output}!"
}

function output-info () {
	# unfying user informative output
	# 1 argument: the string to output
	assert-arg-count "output-info" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local yellow="\e[1;33m"
	>&2 echo -e "${white}(${yellow}*${white}) ${output}."
}

function output-question () {
	# unifying user prompt output (used in is-confirmed)
	# 1 argument: the string to output
	assert-arg-count "output-question" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local blue="\e[1;34m"
	>&2 echo -e "${white}(${blue}?${white}) ${output}?"
}

main "$@"
