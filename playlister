#!/bin/bash

# Hardcoded defaults
	# Immutable
DIR_MAIN="$HOME/.playlister/"
DIR_BKUP="${DIR_MAIN}backups/"
TAR_MP3S="mp3s.tar"
TAR_PLAY="playlists.tar"
FILE_CONFIG="${DIR_MAIN}playlister.conf"
FILE_HELP="${DIR_MAIN}playlister.help"
EXT_PLAY=".plst"
EXT_MP3=".mp3"
EXT_BKUP=".bak"
SEP_MONO="|"			# translating mutli char separators -> single char, for easier processing
USER_INPUT=":"
	# Mutable
DIR_PLAY="${DIR_MAIN}playlists/"
DIR_MP3S="${DIR_MAIN}mp3s/"
SEP_AUAU=", "			# separates authors from other autors
SEP_AUMP=" - " 			# separates authors from the mp3 name

declare -A items_values=()
declare -a items_ordered=()

declare -A CONFIG_VALUES=(
	["DIR_MAIN"]="$DIR_MAIN" 	\
	["DIR_BKUP"]="$DIR_BKUP"	\
	["FILE_CONFIG"]="$FILE_CONFIG" 	\
	["FILE_HELP"]="$FILE_HELP" 	\
	["DIR_PLAY"]="$DIR_PLAY" 	\
	["DIR_MP3S"]="$DIR_MP3S"	\
	["SEP_AUAU"]="$SEP_AUAU"	\
	["SEP_AUMP"]="$SEP_AUMP"
)

declare -a CONFIGS_ALL=(
	"DIR_MAIN" 	\
	"DIR_BKUP"	\
	"FILE_CONFIG" 	\
	"FILE_HELP" 	\
	"DIR_PLAY"	\
	"DIR_MP3S"	\
	"SEP_AUAU"	\
	"SEP_AUMP"
)

declare -a CONFIGS_MUTABLE=(
	"DIR_MP3S" 	\
	"DIR_PLAY"	\
	"SEP_AUAU"	\
	"SEP_AUMP"
)

function main () {
	assert-opt-count "No options given!" ">" 0 "$@"
	while [[ "$#" -gt 0 ]]; do
		case $1 in 
			config)
				shift
				config "$@"
				exit 0
				;;
			show)
				shift
				assert-file-exists 	"$FILE_CONFIG"
				assert-file-readable 	"$FILE_CONFIG"
				read-config
				show "$@"
				exit 0
				;;
			playlist)
				shift
				assert-file-exists 	"$FILE_CONFIG"
				assert-file-readable 	"$FILE_CONFIG"
				read-config
				playlist "$@"
				exit 0
				;;
			check)
				shift
				assert-file-exists 	"$FILE_CONFIG"
				assert-file-readable 	"$FILE_CONFIG"
				read-config
				check "$@"
				exit 0
				;;
			backup)
				shift
				assert-file-exists 	"$FILE_CONFIG"
				assert-file-readable 	"$FILE_CONFIG"
				read-config
				backup "$@"
				exit 0
				;;
			restore)
				shift
				assert-file-exists 	"$FILE_CONFIG"
				assert-file-readable 	"$FILE_CONFIG"
				read-config
				restore "$@"
				exit 0
				;;
			help)
				shift
				assert-file-exists 	"$FILE_HELP"
				assert-file-readable 	"$FILE_HELP"
				cat "$FILE_HELP"
				if ! [[ $? -eq 0 ]]; then
					output-failure "Failed to read \"$FILE_HELP\""
					exit 1
				fi
				exit 0
				;;
			*)
				output-failure "\"$1\" unrecognised option!"
				shift
				exit 1
				;;
		esac
	done
}

function restore() {
	assert-opt-count "No restore options given!" ">" 0 "$@"
	while ! [[ $# -eq 0 ]]; do
		case $1 in
			mp3s | playlists)
				restore-directory "$@"
				if is-items-empty; then
					output-info "No files restored."
				else
					output-info "Files restored:"
					output-items
				fi
				exit 0
				;;
			configs)
				restore-file "$@"
				if is-items-empty ; then
					output-info "No restored configurations to output."
				else
					output-info "Restored configurations:"
					output-items
				fi
				exit 0
				;;
			all)
				restore-file "configs"
				if is-items-empty ; then
					output-info "No restored configurations to output."
				else
					output-info "Restored configurations:"
					output-items
					items-clear
				fi

				restore-directory "playlists"
				if is-items-empty; then
					output-info "No files restored."
				else
					output-info "Files restored:"
					output-items
					items-clear
				fi

				restore-directory "mp3s"
				if is-items-empty; then
					output-info "No files restored."
				else
					output-info "Files restored:"
					output-items
					items-clear
				fi
				exit 0
				;;
			*)
				output-failure "\"$1\" unrecognised restore option!"
				shift
				exit 1
				;;
		esac
	done

}

function restore-file() {
	# assumption: keyword is in array ("configs")
	assert-opt-count "restore file takes 1 option: configs !" "==" 1 "$@"
	local keyword="$1"

	if [[ "$keyword" == "configs" ]]; then
		src="${DIR_BKUP}$(basename "$FILE_CONFIG")${EXT_BKUP}"
		dst="${FILE_CONFIG}"
	fi

	assert-file-exists 	"$src"
	assert-file-readable 	"$src"

	if is-file-exists "$dst"; then
		assert-file-writable "$dst"
	fi

	output-info "Copying \"$src\" to \"$dst\"..."
	cp "$src" "$dst"
	if ! [[ $? -eq 0 ]]; then
		output-failure "Failed to copy \"$src\" to \"$dst\"!"
		exit 1
	fi
	output-success "Copied \"$src\" to \"$dst\"."

	local line
	while read line; do
		add-item "$line"
	done < "$dst"
}

function restore-directory() {
	# assumption: keyword is in ("mp3s" "playlists"), so if keyword not mp3, keyword == "playlists" assumed
	assert-opt-count "[SCRIPT-FAILURE] restore-directory" "==" 1 "$@"
	local keyword="$1"

	local src=""
	local dst=""
	if [[ "$keyword" == "mp3s" ]]; then
		src="${DIR_BKUP}${TAR_MP3S}"
		dst="${DIR_MP3S}"
	else
		src="${DIR_BKUP}${TAR_PLAY}"
		dst="${DIR_PLAY}"
	fi

	assert-file-exists 	"$src"
	assert-file-readable 	"$src"

	assert-file-exists 	"$dst"
	assert-file-readable 	"$dst"
	assert-file-writable 	"$dst"
	tar -x --directory="$dst" -f "$src"
	if ! [[ $? -eq 0 ]]; then
		output-failure "Failed to restore $keyword from \"$src\" to \"$dst\"!"
		exit 1
	fi

	entries="$(tar -tf "$src")"
	while IFS= read -r entry;do
		add-item "$entry"
	done <<< "$entries"
}


function backup() {
	assert-opt-count "No backup options given!" ">" 0 "$@"
	while ! [[ $# -eq 0 ]]; do
		case $1 in
			playlists | mp3s)
				archive-directory-to-backup "$@"
				exit 0
				;;
			configs)
				archive-file "$FILE_CONFIG"
				exit 0
				;;
			all)
				archive-directory-to-backup "playlists"
				archive-directory-to-backup "mp3s"
				archive-file "$FILE_CONFIG"
				exit 0
				;;
			*)
				output-failure "\"$1\" unrecognised backup option!"
				shift
				exit 1
				;;
		esac
	done
}

function archive-file() {
	assert-opt-count "[SCRIPT-FAILURE] archive-file" "==" 1 "$@"

	local file="$1"

	assert-file-exists 	"$DIR_BKUP"
	assert-file-readable	"$DIR_BKUP"
	assert-file-writable	"$DIR_BKUP"

	assert-file-exists	"$file"
	assert-file-readable	"$file"


	if is-file-exists "${DIR_BKUP}$(basename "$file")${EXT_BKUP}"; then
		assert-file-writable "${DIR_BKUP}$(basename "$file")${EXT_BKUP}"
	fi

	output-info 	"Copying \"$file\" to \"$DIR_BKUP\"..."

	cp "$file" "${DIR_BKUP}$(basename "$file")${EXT_BKUP}"
	if ! [[ $? -eq 0 ]]; then
		output-failure "Failed to copy \"$file\" to \"$DIR_BKUP\"!"
		exit 1
	fi

	output-success 	"Copied \"$file\" to \"$DIR_BKUP\"."
}


function archive-directory-to-backup() {
	# assumption: keyword is inside ( "mp3s" "playlists")
	assert-opt-count "backup [mp3s | playlists | all] takes no options!" "==" 1 "$@"
	local keyword="$1"

	local directory
	if [[ "$keyword" == "mp3s" ]]; then
		directory="$DIR_MP3S"
		file="$TAR_MP3S"
	else
		directory="$DIR_PLAY"
		file="$TAR_PLAY"
	fi


	assert-file-exists		"$DIR_BKUP"
	assert-file-readable		"$DIR_BKUP"
	assert-file-writable		"$DIR_BKUP"


	if is-file-exists "${DIR_BKUP}${TAR_MP3S}"; then
		assert-file-writable 	"${DIR_BKUP}${TAR_MP3S}"
	fi


	assert-file-exists 		"$directory"
	assert-file-readable 		"$directory"
	assert-directory-not-empty	"$directory"


	output-info 	"Archiving \"$directory\" into \"${DIR_BKUP}${file}\"..."

	cd "$directory"
	tar --create -f "${DIR_BKUP}${file}" *
	if ! [[ $? -eq 0 ]]; then
		output-failure "Failed to archive \"$directory\" into \"${DIR_BKUP}${file}\"!"
		exit 1
	fi

	output-success 	"Archived \"$directory\" into \"${DIR_BKUP}${file}\"."
}

function playlist() {
	assert-opt-count "No playlist options given!" ">" 0 "$@"
	while ! [[ $# -eq 0 ]]; do
		case $1 in 
			add)
				local playlistname="$2"
				shift 2
				assert-opt-count "No mp3s given!" ">" 0 "$@"
				while [[ $# -gt 0 ]]; do
					local mp3file="$1"
					shift
					playlist-add "$playlistname" "$mp3file"
				done
				if is-items-empty ; then
					output-info "No entries were added."
				else
					output-info "Entries added to \"$playlistname\":"
					output-items
				fi
				exit 0	
				;;
			play)
				shift
				playlist-play "$@"
				exit 0
				;;
			del)
				local playlistname="$2"
				shift 2
				assert-opt-count "No mp3s given!" ">" 0 "$@"
				while [[ $# -gt 0 ]]; do
					local mp3file="$1"
					shift
					playlist-del "$playlistname" "$mp3file"
				done
				if is-items-empty; then
					output-info "No entries were deleted."
				else
					output-info "Entries deleted from \"$playlistname\":"
					output-items
				fi
				exit 0	
				;;
			create)
				shift
				assert-opt-count "No playlist names given!" ">" 0 "$@"
				while [[ $# -gt 0 ]]; do
					local playlist="$1"
					shift
					playlist-create "$playlist"
				done
				if is-items-empty; then
					output-info "No playlists created."
				else
					output-info "Created playlists:"
					output-items
				fi
				exit 0	
				;;
			destroy)
				shift
				assert-opt-count "No playlist names given!" ">" 0 "$@"
				while [[ $# -gt 0 ]]; do
					local playlistname="$1"
					shift
					playlist-destroy "$playlistname"
				done
				if is-items-empty; then
					output-info "No playlists destroyed."
				else
					output-info "Destroyed playlists:"
					output-items
				fi
				exit 0
				;;
			copy)
				shift
				playlist-copy "$@"
				exit 0
				;;
			*)
				output-failure "\"$1\" unrecognized playlist option!"
				exit 1
				;;
		esac

	done
}

function check() {
	assert-opt-count "No check options given!" ">" 0 "$@"
	while ! [[ $# -eq 0 ]]; do
		case $1 in
			mp3s | playlists )
				check-files "$@"
				if is-items-empty; then
					output-info "All files are valid."
				else
					output-info "Invalid files:"
					output-items
				fi
				exit 0
				;;
			playlist)
				shift
				assert-opt-count "No playlists given!" ">" 0 "$@"
				while [[ $# -gt 0 ]]; do
					local playlistname="$1"
					shift
					check-playlist "$playlistname"
					if is-items-empty; then
						output-info "No invalid entries found."
					else
						output-info "Invalid \"$playlistname\" entries:"
						output-items
						items-clear
					fi
				done
				exit 0
				;;
			*)
				output-failure "\"$1\" unrecognized check option!"
				exit 1
				;;
		esac

	done
}

function check-playlist() {
	# checks if every entry in playlist is an existing mp3 file
	assert-opt-count "[SCRIPT-FAILURE] check-playlist" "==" 1 "$@"
	local playlistname="$1"

	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable		"$DIR_MP3S"
	assert-directory-not-empty	"$DIR_MP3S"

	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable		"$DIR_PLAY"
	assert-directory-not-empty	"$DIR_PLAY"

	local playlist="${DIR_PLAY}${playlistname}"
	assert-file-exists 		"$playlist"
	assert-file-readable		"$playlist"

	local entry
	while read -u 69 entry; do
		local mp3file="${DIR_MP3S}${entry}"
		if is-file-exists "$mp3file"; then
			output-success "\"$entry\" reffers to existing file."
			continue
		fi

		output-failure "\"$entry\" does not reffer to existing file!"
		if is-confirmed "Rename \"$entry\"? "; then
			assert-file-writable 	"$DIR_MP3S"
			assert-file-writable 	"$playlist"
			local user
			while : ; do
				output-info "Give new file name of \"$entry\"..."
				user="$(get-user-input)"
				if 	! is-string-valid-mp3name "$user"; then
					output-failure "\"$user\" invalid mp3 file name!"
					continue
				elif 	! is-file-exists "${DIR_MP3S}${user}"; then
					output-failure "\"$user\" does not reffer to existing mp3 file!"
					continue
				fi
				break
			done
			local linecount=1
			while read -u 68 line; do
				if [[ "$line" == "$entry" ]]; then
					sed -i "${linecount}s/$entry/$user/" "$playlist"
					break
				fi
				linecount=$((linecount + 1))
			done 68< "$playlist"
			output-success "\"$entry\" changed to \"$user\"."
		elif is-confirmed "Delete \"$entry\"? "; then
			assert-file-writable 	"$playlist"
			local linecount=1
			while read -u 68 line; do
				if [[ "$line" == "$entry" ]]; then
					sed -i "${linecount}d" "$playlist"
					break
				fi
				linecount=$((linecount + 1))
			done 68< "$playlist"
			output-success "\"$entry\" deleted."
		else
			add-item "$entry"
		fi

	done 69< "$playlist"
}

function check-files() {
	# checks if every file  is formatted according to its type
	# Asumption: keyword given is a valid keyword "playlists" or "mp3s"
	# 1 keyword argument -> "playlists" or "mp3s"

	assert-opt-count "check [ mp3s | playlists ] takes no options!" "==" 1 "$@"
	local keyword="$1"

	local directory
	if [[ "$keyword" == "playlists" ]]; then	directory="$DIR_PLAY"
	else						directory="$DIR_MP3S"
	fi

	assert-file-exists 		"$directory"
	assert-file-readable 		"$directory"
	assert-directory-not-empty	"$directory"

	local file
	for file in "${directory}"*; do
		local filename="$(basename "$file" )"
		local isvalid

		if [[ "$keyword" == "playlists" ]]; then
			if 	is-string-valid-playlist "$filename"; then 	isvalid=0
			else							isvalid=1
			fi
		else # mp3s
			if is-string-valid-mp3name "$filename"; then		isvalid=0
			else 							isvalid=1
			fi
		fi

		if [[ $isvalid -eq 0 ]]; then
			output-success "\"$filename\" valid ${keyword%s}."	# delete s from keyword
			continue
		fi
		output-failure "\"$filename\" invalid ${keyword%s}!"

		if ! is-confirmed "Rename \"$filename\"? "; then
			add-item "$filename"
			continue
		fi

		assert-file-writable "$directory"

		local user
		while : ; do
			output-info "Give new name of \"$filename\"..."
			user="$(get-user-input)"
			local isvalid
			if [[ "$keyword" == "playlists" ]]; then
				if is-string-valid-playlist "$user"; then	isvalid=0
				else						isvalid=1
				fi
			else # mp3s
				if is-string-valid-mp3name "$user"; then	isvalid=0
				else						isvalid=1
				fi
			fi
			if   [[ $isvalid -eq 1 ]]; then
				output-failure "\"$user\" invalid ${keyword%s} name!"
				continue
			elif is-file-exists "${directory}${user}"; then
				output-failure "\"$user\" ${keyword%s} exists!"
				continue
			fi
			break
		done
		mv "$file" "${directory}${user}"
		output-success "Renamed \"$filename\" to \"$user\"."
	done
}

function is-string-valid-playlist() {
	# does not validate user string propelly(slashes), oh well!
	assert-opt-count "[SCRIPT-FAILURE] is-string-valid-playlist" "==" 1 "$@"
	local playlistname="$1"
	if !	[[ "$playlistname" == *"${EXT_PLAY}" ]]; then
		return 1
	fi
	return 0

}

function is-string-valid-mp3name () {
	# does not validate user string propelly(slashes), oh well!
	assert-opt-count "[SCRIPT-FAILURE] is-string-valid-mp3name" "==" 1 "$@"
	local mp3name="$1"
	local authors="$(get-from-filename "$mp3name" "authors")"
	echo "authors is \"$authors\""
	if [[ "$authors" == "" ]]; then
		return 1
	fi

	local mp3name="$(get-from-filename "$mp3name" "mp3")"
	echo "mp3name is \"$mp3name\""
	if 	[[ "$mp3name" == "" ]]; then
		return 1
	elif	! [[ "$mp3name" == *"${EXT_MP3}" ]]; then
		return 1
	fi
	return 0

}

function get-user-input() {
	assert-opt-count "[SCRIPT-FAILURE] get-user-input" "==" 0 "$@"
	local user
	read -p "${USER_INPUT}" user
	echo "$user"

}

function playlist-play () {
	# for entry in playlist given, give it to mpg123 program for playing
	# exit 1 on failure
		# failure:
			# wrong arg count
			# playlist directory does not exist, is unreadable, is empty
			# playlist file does not exist, is unreadable
			# mp3 directory does not exist, is unreadable, is empty
			# mpg123 failed to play mp3 file
	# 1 argument
		# the basenamed name of the playlist
		# keyword for the order in which mp3 files should be outputted
	assert-opt-count "playlist play takes 2 options: <playlist> [ random | original ] !" "==" 2 "$@"
	local playlistname="$1"
	local keyword="$2"

	local valid_keywords=( "random" "original" )
	if ! is-element-in-array "$keyword" "valid_keywords" ;then 
		#
		output-failure "\"$keyword\" invalid keyword!"
		exit 1
	fi


	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable 		"$DIR_PLAY"
	assert-directory-not-empty 	"$DIR_PLAY"

	local playlist="${DIR_PLAY}${playlistname}"
	assert-file-exists 		"$playlist"
	assert-file-readable 		"$playlist"

	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty 	"$DIR_MP3S"

	local entry

	local tmpfile=$(mktemp /tmp/playlister-temp.XXXXXX)
	exec 3>"$tmpfile"
	exec 4<"$tmpfile"
	
	if 	[[ "$keyword" == "random" ]]; then
		echo "$(cat "$playlist" | sort -R )" 	>&3
	elif 	[[ "$keyword" == "original" ]]; then
		echo "$(cat "$playlist" )" 		>&3
	else
		output-failure "\"$keywordl\" rouge keyword caught!"
		exit 1
	fi

	local lastnumber="$(cat "$tmpfile" | wc -l )"
	local currnumber=1

	while read entry; do
		output-info "	Playing(${currnumber}/${lastnumber}): $entry \n \
				To skip song, press : 	CTRL + C\n\
				To end playing, hold: 	CTRL + C\n\
				\n"

		local mp3="${DIR_MP3S}${entry}"
		mpg123 "$mp3" 2> /dev/null
		if ! [[ $? -eq 0 ]]; then
			output-failure "mpg123 failed to play \"$entry\"!"
			exit 1
		fi
		currnumber=$(( currnumber + 1 ))
	done <&4
}

function playlist-add() {
	# to playlist, add mp3 file that is valid and not an entry, also add it to items
	# exit 1 on failure
		# failures:
			# wrong arg count
			# playlist directory does not exist, not readable, or empty
			# playlist file does not exist, not readable, not writable
			# mp3 directory does nto exist, not readable, or empty
	# 2 arguments;
		# 1) 	basenamed playlist filename
		# 2)  	basenamed mp3file to add
	assert-opt-count "[SCRIPT-FAILURE]" "==" 2 "$@"
	local playlistname="$1"
	local entryname="$2"
	shift 2

	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable 		"$DIR_PLAY"
	assert-directory-not-empty 	"$DIR_PLAY"

	local playlist="${DIR_PLAY}${playlistname}"

	assert-file-exists 	"$playlist"
	assert-file-readable 	"$playlist"
	assert-file-writable 	"$playlist"

	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty	"$DIR_MP3S"

	local entry="${DIR_MP3S}${entryname}"

	assert-file-exists "$entry"
	if is-line-in-file "$entryname" "$playlist"; then
		output-info "\"$entryname\" already in \"$playlistname\"."
	else
		echo "$entryname" >> "$playlist"
		if ! [[ $? -eq 0 ]]; then
			output-failure "Failed to append \"$entry\" to \"$playlistname\"!"
			exit 1
		fi
		add-item "$entryname"
	fi
}

function playlist-del() {
	# delete <entry> from <playlist> (if <entry> in <playlist>)
		# exit 1 on failure
			# failure:
				# DIR_PLAY does not exist, not readable, or empty
				# given playlist does not exist, unreadable or unwritable
				# DIR_MP3S does not exist, not readable or empty
	# arguments:
		# 1) basenamed playlist name
		# 2) entry
	assert-opt-count "[SCRIPT-FAILURE] playlist-del" "==" 2 "$@"
	local playlistname="$1"
	local entry="$2"
	shift 2

	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable 		"$DIR_PLAY"
	assert-directory-not-empty 	"$DIR_PLAY"

	local playlist="${DIR_PLAY}${playlistname}"

	assert-file-exists 	"$playlist"
	assert-file-readable 	"$playlist"
	assert-file-writable 	"$playlist"

	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty	"$DIR_MP3S"

	if is-line-in-file "$entry" "$playlist"; then
		local linecount="$(get-line-file-index "$entry" "$playlist")"
		sed -i "${linecount}d" "$playlist"
		add-item "$entry"
	else
		output-info "\"$entry\" not in \"$playlistname\"."
	fi
}

function playlist-create() {
	# create <playlist> and add it to items
		# exit 1 on failure
			# failure:
				# DIR_PLAY does not exists, unreadable, unwritable 
				# playlist of the given name already exists
	# 1 argument:
		# the basenamed name of the playlist
	assert-opt-count "[SCRIPT-FAILURE] playlist-create" "==" 1 "$@"
	local playlistname="$1"

	# DiR_PLAY should not fail to create playlist even if playlist is empty
	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable		"$DIR_PLAY"
	assert-file-writable 		"$DIR_PLAY"

	local playlist="${DIR_PLAY}${playlistname}"

	if is-file-exists "$playlist"; then
		output-info "\"$playlistname\" exists."
	elif ! is-string-valid-playlist "$playlistname"; then
		output-failure "\"$playlistname\" invalid playlist name!"
	else
		touch "$playlist"
		if ! [[ $? -eq 0 ]]; then
			output-failure "Failed to create \"$playlistname\"!"
			exit 1
		fi
		add-item "$playlistname"
	fi
}

function playlist-destroy() {
	# delete an existing playlist of given name
		# exit 1 on failure
			# failure:
				# DIR_PLAY does not exists, unreadable, unwritable 
				# playlist of the given name does not exist
	# 1 argument:
		# the basenamed name of the playlist
	assert-opt-count "[SCRIPT-FAILURE] playlist-destroy" "==" 1 "$@"
	local playlistname="$1"

	# DiR_PLAY should not fail to playlist even if playlist is empty
	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable		"$DIR_PLAY"
	assert-directory-not-empty	"$DIR_PLAY"
	assert-file-writable 		"$DIR_PLAY"

	local playlist="${DIR_PLAY}${playlistname}"

	if ! is-file-exists "$playlist"; then
		output-failure "\"$playlistname\" does not exist!"
		exit 1
	else
		rm "$playlist"
		add-item "$playlistname"
	fi
}

function playlist-copy() {
	# copy an existing given playlist into a new playlist of given new name
		# exit 1 on failure
			# DIR_PLAY does not exist, unreadable, empty, unwritable
			# existiing playlist does not exist
			# new playlist already exists
	# 2 arguments
		# 1) existing playlist
		# 2) new playlist
	assert-opt-count "playlist copy takes 2 arguments: <existing-file> <new-file> !" "==" 2 "$@"
	local existplaylistname="$1"
	local newplaylistname="$2"

	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable		"$DIR_PLAY"
	assert-directory-not-empty	"$DIR_PLAY"
	assert-file-writable 		"$DIR_PLAY"

	local existplaylist="${DIR_PLAY}${existplaylistname}"
	local newplaylist="${DIR_PLAY}${newplaylistname}"


	if ! is-file-exists "$existplaylist"; then
		output-failure "\"$existplaylistname\" does not exist!"
		exit 1
	fi

	if is-file-exists "$newplaylist"; then
		output-failure "\"$newplaylistname\" exists!"
		exit 1
	fi

	cp "$existplaylist" "$newplaylist"
	if ! [[ $? -eq 0 ]]; then
		output-failure "Failed to copy \"$existplaylistname\" to \"$newplaylistname\"!"
		exit 1
	fi
	output-success "Copied \"$existplaylistname\" to \"$newplaylistname\"."
}

function show () {
	assert-opt-count "No show options given!" ">" 0 "$@"
	while ! [[ $# -eq 0 ]]; do
		case $1 in
			authors)
				shift
				if 	[[ $# -eq 0 ]]; then
					show-authors
					if is-items-empty; then
						output-info "No authors to output."
					else
						output-info "Authors:"
						output-items
					fi
				else
					while ! [[ $# -eq 0 ]]; do
						local mp3name="$1"
						shift
						show-authors-of-mp3 "$mp3name"
						if is-items-empty; then
							output-info "\"$mp3name\" not found."
						else
							output-info "Authors of \"$mp3name\":"
							output-items
						fi
						items-clear
					done
				fi
				exit 0
				;;
			playlists)
				shift
				show-playlists "$@"
				if is-items-empty; then
					output-info "No playlists to output."
				else
					output-info "Playlists:"
					output-items
				fi
				exit 0
				;;
			mp3s)
				shift
				show-mp3s "$@"
				if is-items-empty; then
					output-info "No mp3s to output."
				else
					output-info "Mp3s:"
					output-items
				fi
				exit 0
				;;
			author)
				shift
				assert-opt-count "No authors given!" ">" 0 "$@"
				while ! [[ $# -eq 0 ]]; do
					local author="$1"
					shift
					show-author "$author"

					if is-items-empty; then
						output-info "No mp3 files of \"$author\" to output."
					else
						output-info "Mp3 files of \"$author\":"
						output-items
					fi
					items-clear
				done
				exit 0
				;;
			playlist)
				shift
				assert-opt-count "No playlists given!" ">" 0 "$@"
				while ! [[ $# -eq 0 ]]; do
					local playlistname="$1"
					shift
					show-playlist "$playlistname"
					if is-items-empty; then
						output-info "\"$playlistname\" is empty."
					else
						output-info "Entries in \"$playlistname\":"
						output-items
					fi
					items-clear
				done
				exit 0
				;;
			mp3)
				shift
				assert-opt-count "no mp3s given!" ">" 0 "$@"
				while ! [[ $# -eq 0 ]]; do
					local mp3name="$1"
					shift
					show-mp3 "$mp3name"
					if is-items-empty; then
						output-info "No playlist contains \"$mp3name\""
					else
						output-info "Playlists containing \"$mp3name\":"
						output-items
					fi
					items-clear
				done
				exit 0
				;;
			*)
				output-failure "\"$1\" unrecognised show option!"
				exit 1
				;;
		esac
	done
}

function show-mp3 () {
	# add every playlist to items, if playlist has $mp3name
	# return execution on success, ext 1 on failure
		# failure:
			# wrong arg count
			# DIR_MP3S does not exist, is unreadable or is empty
			# mp3name does not point to an existing mp3 file
			# DIR_PLAY does not exist, is unreadable or is empty
			# a playlist file is unreadable
	# 1 argument:
		# basenamed filename of the mp3 file
	assert-opt-count "[SCRIPT-FAILURE] show-mp3" "==" 1 "$@"
	local mp3name="$1"

	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty 	"$DIR_MP3S"

	local mp3="${DIR_MP3S}${mp3name}"

	assert-file-exists 		"$mp3"

	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable 		"$DIR_PLAY"
	assert-directory-not-empty 	"$DIR_PLAY"		

	local file
	for file in "${DIR_PLAY}"*; do
		local filename="$(basename "$file" )"
		assert-file-readable "$file"
		if is-line-in-file "$mp3name" "$file"; then
			add-item "$filename"
		fi
	done
}

function show-playlist () {
	# add every playlist entry to items
	# return code on execution on success , exit 1 on failure
		# failure:
			# wrong argument count
			# mp3 directory does not exist, unreadable or empty
			# playlistname points to a nonexistant mp3 file
			# playlist directory does not exist, unreadable, or empty
	# 1 argument: 
		# playlist filename(basename'd)
	assert-opt-count "[SCRIPT-FAILURE] show-playlist" "==" 1 "$@"
	local playlistname="$1"

	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable 		"$DIR_PLAY"
	assert-directory-not-empty 	"$DIR_PLAY"

	local playlist="${DIR_PLAY}${playlistname}"
	assert-file-exists 		"$playlist"
	assert-file-readable 		"$playlist"

	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty 	"$DIR_MP3S"
	while IFS= read -ru 69 entry; do
		add-item "$entry"
	done 69<"$playlist"
}

function is-confirmed () {
	# get user yes, no input to make simple script decisions
	# return 0 if confirmed, return 1 if rejected, exit 1 on error
		# failures: wrong arg count
	# 1 argument: string prompt to display
	assert-opt-count "is-confirmed" "==" 1 "$@"
	local prompt="$1"

	local confirmation=( "y" "ye" "yes" "Y" "Ye" "Yes" "YE" "YES" )
	local rejection=("n" "no" "N" "No" "NO" )
	while : ; do
		output-question "$prompt"
		local user="$(get-user-input)"
		local option
		if is-element-in-array "$user" "confirmation"; then
			return 0
		elif is-element-in-array "$user" "rejection"; then
			return 1
		fi

		output-failure "Invalid user input: \"$user\"!"
	done
}



function show-author () {
	# add every mp3 file name the <author> is author of to items
	# return execution flow on success, exit 1 on failure
		# failure: 
			# wrong arg count
			# DIR_MP3S does not exist, is unreadable or empty
	# 1 argument: 
		# the name of the author
	assert-opt-count "[SCRIPT-FAILURE] show-author" "==" 1 "$@"
	local target_author="$1"
	
	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty 	"$DIR_MP3S"

	local file
	for file in "$DIR_MP3S"*; do
		local filename="$(basename "$file")"
		local mp3name="$(get-from-filename "$filename" "mp3")"
		local authors="$(get-from-filename "$filename" "authors")" 	# split from full filename
		authors="$(divide-authors "$authors")" 				# divide from SEP_AUAU to SEP_MONO
		IFS="${SEP_MONO}" read -ra authors <<< "$authors"				# split with SEP_MONO
		local author
		for author in "${authors[@]}"; do
			if [[ "$author" == "$target_author" ]]; then
				add-item "$mp3name"
			fi
		done
	done
}

function show-authors () {
	# add every author in mp3 directory to items with their respective number of "author'ed" files
	# return execution flow on success, exit 1 on failure
		# failure: 
			# DIR_MP3S does not exist, unreadable or empty
			# failed to add/increment author in items
	# no arguments

	assert-opt-count "[SCRIPT-FAILURE] show-authors" "==" 0 "$@"

	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty 	"$DIR_MP3S"
	local file
	for file in "$DIR_MP3S"*; do
		local filename="$(basename "$file")"
		local mp3name="$(get-from-filename "$filename" "mp3")"
		local authors="$(get-from-filename "$filename" "authors")" 	# split from full filename
		authors="$(divide-authors "$authors")" 				# divide from SEP_AUAU to SEP_MONO
		IFS="${SEP_MONO}" read -ra authors <<< "$authors"		# split with SEP_MONO 
		local author
		for author in "${authors[@]}"; do
			add-item "$author"
		done

	done
}

function show-authors-of-mp3 () {
	# adds every author in mp3 directory that is author of mp3 file which name is <mp3>
	# return execution flow n success, exit 1 on failure
		# failure:
			# wrong arg count
			# mp3 directory does not exist, is unreadable or empty
	# 1 argument:
		# the target mp3 file name (without authors, with mp3 extension)
	assert-opt-count "[SCRIPT-FAILURE] show-authors-of-mp3" "==" 1 "$@"
	local target_mp3name="$1"


	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty 	"$DIR_MP3S"
	local file
	for file in "$DIR_MP3S"*; do
		local filename="$(basename "$file" )"
		local mp3name="$(get-from-filename "$filename" "mp3")"
		if [[ "$mp3name" == "$target_mp3name" ]]; then
			local authors="$(get-from-filename "$filename" "authors")"
			authors="$(divide-authors "$authors")"
			IFS="${SEP_MONO}" read -ra authors <<< "$authors"
			local author
			for author in "${authors[@]}"; do
				add-item "$author"
			done
		fi

	done
}

function show-mp3s () {
	# adds every mp3 file to items
	# return execution flow on success, exit 1 on failure
		# success: all files were looped and added to items
		# failures:
			# wrong arg count
			# arg not in ["all", "used", "unused"]
			# mp3 directory not readable
			# mp3 directory empty
			# is-mp3-used fail
	# 1 argument: type of mp3: ["all", "used", "unused"]
	# implementation of playlister show mp3 <type>

	assert-opt-count "show mp3s takes 1 option: [ all | used | unused ] !" "==" 1 "$@"
	local keyword="$1"
	local valid_keywords=( "all" "used" "unused")
	if ! is-element-in-array "$keyword" "valid_keywords"; then
		output-failure "\"$keyword\" invalid keyword!"
		exit 1
	fi
	
	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty 	"$DIR_MP3S"



	for file in "${DIR_MP3S}"*; do
		local filename="$(basename "$file" )"
		case "$keyword" in
			"all")
				add-item "$filename"
				;;
			"used")
				assert-file-exists 		"$DIR_PLAY"
				assert-file-readable		"$DIR_PLAY"
				assert-directory-not-empty	"$DIR_PLAY"
				local file
				for file in "${DIR_PLAY}"*; do		# playlist check for is-mp3-used
					assert-file-readable "$file"
				done

				if is-mp3-used "$filename"; then
					add-item "$filename"
				fi
				;;
			"unused")
				assert-file-exists 		"$DIR_PLAY"
				assert-file-readable		"$DIR_PLAY"
				assert-directory-not-empty	"$DIR_PLAY"
				local file
				for file in "${DIR_PLAY}"*; do		# playlist check for is-mp3-used
					assert-file-readable "$file"
				done

				if ! is-mp3-used "$filename"; then
					add-item "$filename"
				fi
				;;
			*)
				output-failure "How did \"$keyword\" slip through the argument check?!"
		esac
	done
}

function is-mp3-used () {
	# checks if mp3 file is entry in a playlist
	# Assumption: 
			# DIR_PLAY exists, readable and not empty, 
			# every playlist is readable
	# return int status as value, exit 1 on error
		# success: return status
			# 0 -> mp3 is used
			# 1 -> mp3 is not used
		# failure:
			# wrong arg count
	# 1 argument: 
		# filename to be checked (previously basename'd!)
	assert-opt-count "is-mp3-used" "==" 1 "$@"
	local filename="$1"
	
	local playlist
	for playlist in "${DIR_PLAY}"* ; do
		local line
		if is-line-in-file "$filename" "$playlist"; then
			return 0
		fi
	done
	return 1
}

function show-playlists () {
	# add every playlist to items
	# return execution flow if success, exit 1 if failure
		# success: all playlists added to items
		# failure:
			# wrong arg count
			# playlist does not exits, unreadable or empty
	# no arguments

	assert-opt-count "show playlist does not take any options!" "==" 0 "$@"

	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable 		"$DIR_PLAY"
	assert-directory-not-empty 	"$DIR_PLAY"

	local file
	for file in "${DIR_PLAY}"* ; do
		local filename="$(basename "$file")"
		add-item "$filename"
	done
}

function get-from-filename () {
	
	assert-opt-count "get-from-filename" "==" 2 "$@"
	
	local filename="$1"
	local keyword="$2"

	local valid_keywords=( "mp3" "authors" )

	if ! is-element-in-array "$keyword" "valid_keywords"; then
		output-failure "\"$keyword\" invalid keyword!"
		exit 1
	fi

	local tmp=${filename//"${SEP_AUMP}"/${SEP_MONO}}
	local authors
	local mp3
	IFS="${SEP_MONO}" read authors mp3 <<< "$tmp"
	
	if 	[[ "$keyword" == "authors" ]]; then
		echo "$authors"
	elif 	[[ "$keyword" == "mp3" ]]; then
		echo "$mp3"
	fi
}

function divide-authors (){
	assert-opt-count "divide-authors" "==" 1 "$@"
	local authors_string="$1"
	local authors=${authors_string//"${SEP_AUAU}"/"${SEP_MONO}"}
	echo "$authors"
	
}

function config () {
	assert-opt-count "No config options given!" ">" 0 "$@"
	while [[ "$#" -gt 0 ]]; do
		case $1 in
			configure)
				shift
				config-configure "$@"
				exit 0
				;;
			list)
				shift
				assert-file-exists 	"$FILE_CONFIG"
				assert-file-readable 	"$FILE_CONFIG"
				read-config
				config-list "$@"
				if is-items-empty; then
					output-failure "Wait, no configs? Thats impossible..."
					exit 1
				else
					output-info "Current configurations:"
					output-items
				fi
				exit 0
				;;
			get)
				shift
				assert-opt-count "No configurations given!" ">" 0 "$@"
				assert-file-exists 	"$FILE_CONFIG"
				assert-file-readable 	"$FILE_CONFIG"
				read-config
				while ! [[ $# -eq 0 ]]; do  
					config-get "$1"
					shift
				done
				if is-items-empty; then
					output-info "No configurations to output."
				else
					output-info "Configurations:"
					output-items
				fi
				exit 0
				;;
			set)	
				shift
				assert-file-exists 	"$FILE_CONFIG"
				assert-file-readable 	"$FILE_CONFIG"
				read-config
				config-set "$@"
				config-get "$1"
				if is-items-empty; then
					output-failure "Wait, no configs? Thats impossible..."
					exit 1

				else
					output-info "Configurations:"
					output-items
				fi
				exit 0
				;;
			*)
				output-failure "\"$1\" unrecognised config option!"
				exit 1
				;;
		esac
	done
}
function config-configure () {
	assert-opt-count "config configure does not take any options!" "==" 0 "$@"
	
	directory-config "$DIR_MAIN"

	directory-config "$DIR_BKUP"
	
	file-configure 	"$FILE_HELP" "currentdir"
	
	file-configure 	"$FILE_CONFIG" "backup" "makenew"

	assert-file-exists 	"$FILE_CONFIG"		# just to be sure there ain't any mask weird stuff
	assert-file-readable 	"$FILE_CONFIG"
	
	if read-config ; then
		output-success "$(basename "$FILE_CONFIG") read."
	else
		output-failure "$(basename "$FILE_CONFIG") failed to read!"
		exit 1
	fi
	
	directory-config "$DIR_MP3S"

	directory-config "$DIR_PLAY"

	if ! command -v mpg123 2>&1 >/dev/null; then
		output-failure "\"mpg123\" not found, please install \"mp123\" if not installed already!"
		exit 1
	fi
	output-info "\"mpg123\" found."

	if ! command -v sed 2>&1 >/dev/null; then
		output-failure "\"sed\" not found, please install \"sed\" if not installed already!"
		exit 1
	fi
	output-info "\"sed\" found."
}

function config-list () {
	assert-opt-count "config list does not take any options!" "==" 0 "$@"

	local configuration
	for configuration in "${CONFIGS_ALL[@]}"; do
		# i do not need to check for validity of $configuration here
		# for $configuration is fetched directly from $CONFIG_VALUES
		config-get "$configuration"
	done
}

function config-get () {
	assert-opt-count "config get takes 1 argument: <config-name> !" "==" 1 "$@"
	local configuration="$1"
	if ! is-element-in-array "$configuration" "CONFIGS_ALL"; then
		output-failure "\"$configuration\" invalid configuration!"
	else
		add-item "	$configuration	-> 	\"${CONFIG_VALUES[$configuration]}\""
	fi
}

function config-set () {
	assert-opt-count "config set takes 2 arguments: <config-name> <value> !" "==" 2 "$@"

	local configuration="$1"
	local newvalue="$2"
	if ! is-element-in-array "$configuration" "CONFIGS_ALL"; then
		output-failure "\"$configuration\" invalid configuration!"
		exit 1
	fi
	if ! is-element-in-array "$configuration" "CONFIGS_MUTABLE"; then
		output-failure "\"$configuration\" configuration not mutable!"
		exit 1
	fi

	assert-file-exists	"$FILE_CONFIG"
	update-config-file "$configuration" "$newvalue"
}

function update-config-file () {
	assert-opt-count "[SCRIPT-FAILURE] update-config-file" "==" 2 "$@"
	local configuration="$1"
	local newvalue="$2"

	assert-file-exists 	"$FILE_CONFIG"
	assert-file-readable 	"$FILE_CONFIG"
	assert-file-writable 	"$FILE_CONFIG"
	sed -i "/^${configuration}=/d" "$FILE_CONFIG"
	echo "${configuration}=${newvalue}" >> "$FILE_CONFIG"
}

function directory-config () {
	# configure directory creation for eg. config configure
	# return to execution on success, exit 1 on failure
		# failures:
			# could not create directory
			# directory is a file rather than a directory
			# directory is not readable
	# arguments:
		# full path of the directory
	assert-opt-count "[SCRIPT-FAILURE] directory-config" "==" 1 "$@"
	local dir="$1"
	local dirname="$(basename "$dir" )"
	if ! is-file-directory-exists "$dir"; then
		output-info "\"$dirname\" does not exist."
		# is-file-directory-exists will omit ${dir%/} 
		# but mkdir treats $dir and ${dir%/} the same
		# and will fail if ${dir%/} exists
		if is-file-exists "${dir%/}"; then
			output-failure "\"$dirname\" can't be created because \"${dir%/}\" file exists!"
			exit 1
		fi
		mkdir "$dir"
		if ! [[ $? -eq 0 ]]; then
			output-failure "\"$dirname\" failed to create!"
			exit 1
		fi
		output-info "\"$dirname\" created."
	fi
	output-info "\"$dirname\" exists."

	assert-file-directory "$dir"

	output-info "\"$dirname\" is a directory."

	assert-file-readable "$dir"

	output-info "\"$dirname\" is readable."
}


function file-configure () {
	assert-opt-count "[SCRIPT-FAILURE] file-configure" ">" 1 "$@"
	local file="$1"
	local filename="$( basename "$file" )"
	local backup=0
	local currentdir=0
	local makenew=0
	shift
	while [[ "$#" -ne 0 ]]; do
		case $1 in 
			"backup")
				backup=1
				shift
				;;
			"currentdir")
				currentdir=1
				shift
				;;
			"makenew")
				makenew=1
				shift
				;;
			*)
				output-failure "unrecognised file-configure option:\"$1\"!"
				return 1
				;;
		esac
	done

	if is-file-exists "$file"; then
		output-info "$filename exists."
		return 0
	fi
	output-info "$filename does not exist."
	
	if [[ $backup -eq 1 ]]; then
		local fileback="${DIR_BKUP}${filename}${EXT_BKUP}"
		if is-file-exists "$fileback"; then
			cp "$fileback" "$file"
			if [[ $? -eq 0 ]]; then
				output-success "$filename created from backup."
				return
			fi
			output-info "$filename failed to create from backup."
		fi
		output-info "$filename does not have a backup."
	fi

	if [[ $currentdir -eq 1 ]]; then
		if is-file-exists "$filename"; then
			cp "$filename" "$file"
			if [[ $? -eq 0 ]]; then
				output-success "$filename created from current directory."
				return
			fi
			output-info "$filename failed to create from current directory."
		fi
		output-info "$filename not found in current directory."
	fi

	if [[ $makenew -eq 1 ]]; then
		touch "$file"
		if [[ $? -eq 0 ]]; then
			output-success "$filename created blank."
			return 0
		fi
		output-failure "$filename failed to create blank!"
	fi
	
	output-failure "$filename configuration failed!"
	exit 1 
}

function read-config () {
	# assumption: FILE_CONFIG exists and is readable
	assert-opt-count "[SCRIPT-FAILURE] read-config" "==" 0 "$@"
	while read line ; do
		local argument="$(echo "$line" | cut -d "=" -f 1)"
		case "$argument" in
			"DIR_MP3S")
				local value="$(echo "$line" | cut -d "=" -f 2)"
				DIR_MP3S="$value"
				CONFIG_VALUES["DIR_MP3S"]="$value"
				;;
			"DIR_PLAY")
				local value="$(echo "$line" | cut -d "=" -f 2)"
				DIR_PLAY="$value"
				CONFIG_VALUES["DIR_PLAY"]="$value"
				;;
			"SEP_AUAU")
				local value="$(echo "$line" | cut -d "=" -f 2)"
				SEP_AUAU="$value"
				CONFIG_VALUES["SEP_AUAU"]="$value"
				;;
			"SEP_AUMP")
				local value="$(echo "$line" | cut -d "=" -f 2)"
				SEP_AUMP="$value"
				CONFIG_VALUES["SEP_AUMP"]="$value"
				;;
			*)
				output-failure "\"$argument\" invalid configuration found in \"$FILE_CONFIG\"!"
				return 1
				;;
		esac
	done < "$FILE_CONFIG"
}

function assert-directory-not-empty () {
	# check if directory is empty
	# assumption: directory exists and is readable
	# return to execution flow on success, exit on failure
		# success -> directory is not empty 
		# failure -> directory is empty
	# 1 argument: the directory
	assert-opt-count "[SCRIPT-FAILURE] assert-directory-not-empty" "==" 1 "$@"
	local directory="$1"

	if ! find "$directory" -mindepth 1 -maxdepth 1 | read; then
		output-failure "\"$(basename "$directory")\" is empty!"
		exit 1
	fi
}

function assert-file-writable () {
	# check if file is writable
	# return to execution flow no success, exit on failure
	# Assumption: file exists
	# 1 argument: 
		# full path to the file
	assert-opt-count "[SCRIPT-FAILURE] assert-file-writable" "==" 1 "$@"
	local file="$1"
	file="${file%/}"	# trim slash if file given for when the file given is a directory.
	if ! [[ -w "$file" ]]; then
		output-failure "\"$(basename "$file")\" not writable!"
		exit 1
	fi

}

function assert-file-readable () {
	# check if file is readable
	# Assumption: file exists
	# return to execution flow on success, exit on failure
		# success -> file is readable
		# failure -> file is not readable
	# 1 argument: the file
	assert-opt-count "[SCRIPT-FAILURE] assert-file-readable" "==" 1 "$@"
	local file="$1"
	file="${file%/}"	# trim slash if file given for when the file given is a directory.
	local filename="$(basename "$file")"
	if ! [[ -r "$file" ]]; then
		output-failure "\"$filename\" not readable!"
		exit 1
	fi
}

function assert-file-exists (){
	# check for file existence
	# return execution flow if file exists, exit 1 otherwise
	# 1 argument:
		# the full path to the file
	assert-opt-count "[SCRIPT-FAILURE] assert-file-exists" "==" 1 "$@"
	local file="$1"
	if ! [[ -e "$file" ]]; then
		output-failure "\"$file\" does not exist!"
		exit 1
	fi
}

function is-file-exists () {
	# determine if file exists
	# return 0 if file exists, return 1 if file does not exist
	# 1 argument:
		# the full path to the file
	assert-opt-count "[SCRIPT-FAILURE] is-file-exists" "==" 1 "$@"
	local file="$1"
	if [[ -e "$file" ]]; then
		return 0
	fi
	return 1
}

function is-file-directory-exists () {
	# determine if file exists and is a directory
	# return 0 if file exists and is a directory, return 0 otherwise
	# 1 argument:
		# the full path to the file
	assert-opt-count "[SCRIPT-FAILURE] is-file-directory-exists" "==" 1 "$@"
	local file="$1"
	if [[ -d "$file" ]]; then
		return 0
	fi
	return 1
}

function assert-file-directory () {
	# determine if file exists and is a directory
	# return execution flow on success, exit 1 on failure
	# 1 argument:
		# the full path to the file
	assert-opt-count "[SCRIPT-FAILURE] assert-file-directory" "==" 1 "$@"
	local file="$1"
	local filename="$(basename "$file")"
	if ! [[ -d "$file" ]]; then
		output-failure "\"$filename\" not a directory!"
		exit 1
	fi
}

function assert-opt-count () {
	# Check if function given correct arg amount.
	# return execution flow on success, exit 1 on failure
		# success: correct arg count given to function
		# failure:
			# wrong arg count given to assert-corr...
			# invalid operator given
			# assertion failed
	# Arguments:
		# prompt 			-> failure output
		# operator 			-> keyword together with argcount specifying the argument count
		# argcount 			-> a point of refrence for arguments expected
		# optional arguments... 	-> arguments given originally to func
	# the func arguments need to be inputted with [@] (protect from "My Argument" arguments with [*])
	if ! [[ $# -ge 3 ]]; then
		output-failure "assert-opt-count: invalid argument count(must be >= 3, but {$#} were given)!"
		exit 1
	fi
	local failure_output="$1"


	local operator="$2"
	local accepted_operators=( "==" ">" "<" )
	# cant use is-element-in-array here, at it produces an infinite loop
	local accepted_operator
	local inside=0
	for accepted_operator in "${accepted_operators[@]}"; do
		if [[ "$accepted_operator" == "$operator" ]]; then
			inside=1
		fi
	done
	if ! [[ $inside -eq 1 ]]; then
		output-failure "assert-opt-count: \"$operator\" not a valid operator( one of: ${accepted_operators[*]})!"
		exit 1
	fi
	local argcount="$3"
	local positive_num_re="^[0-9]+$"
	if ! [[ $argcount =~ $positive_num_re ]]; then
		output-failure "assert-opt-count: \"$argcount\" not a valid positive integer!"
		exit 1
	fi

	shift 3

	if  ( [[ "$operator" == ">"  ]] &&  ! [[ $# -gt $argcount ]] ) || \
	    ( [[ "$operator" == "==" ]] &&  ! [[ $# -eq $argcount ]] ) || \
	    ( [[ "$operator" == "<"  ]] &&  ! [[ $# -lt $argcount ]] ) ; then

		output-failure "$failure_output"
		exit 1
	fi
}

function add-item () {
	# add string item to items with initalized count, or if already exists: increase counter.
	# return to execution flow on success, exit on failure
		# failure -> invalid argument count
	# 1 argument: 
		# string item to be added 
	assert-opt-count "[SCRIPT-FAILURE] add-item" "==" 1 "$@"
	local new_item="$1"
	if is-element-in-array "$new_item" "items_ordered"; then
		items_values["$new_item"]=$(( ${items_values["$new_item"]} + 1 ))
	else
		items_ordered+=("$new_item") 
		items_values["$new_item"]=$(( 1 ))
	fi
}

function is-element-in-array() {
	# checks if argument is in array
	# return 0 if yes, 1 if not, exit 1 on failure
		# failure:
			# wrong arg count
	# 2 arguments
		# 1) element to be checked
		# 2) name of array
	assert-opt-count "[SCRIPT-FAILURE] is-element-in-array" "==" 2 "$@"
	local element="$1"
	local arraynameargs="$2[@]"
	local array=("${!arraynameargs}")		# "(" ")" to treat as array
	local array_element
	for array_element in "${array[@]}"; do
		if [[ "$array_element" == "$element" ]]; then
			return 0
		fi
	done
	return 1
}

function is-line-in-file() {
	# checks if given line in given file
	# assumption: 
		# file exists and is readable
	# return 0 if yes, 1 if not, exit 1 on failure
		# failure:
			# wrong arg count
	# 2 arguments
		# 1) line
		# 2) full path to file
	assert-opt-count "[SCRIPT-FAILURE] is-line-in-file" "==" 2 "$@"
	local target_line="$1"
	local file="$2"
	local line
	while read line; do
		if [[ "$line" == "$target_line" ]]; then
			return 0
		fi
	done <"$file"
	return 1
}

function get-line-file-index() {
	# get the line number of line which is string inside file
	# assumption: 
		# file exists and is readable
	# return 0 if yes, 1 if not, exit 1 on failure, the is echoed out to catch into a variable
		# failure:
			# wrong arg count
	# 2 arguments
		# 1) line
		# 2) full path to file
	# line numbering is done with the first line being 1
	assert-opt-count "[SCRIPT-FAILURE] get-line-index-in-file" "==" 2 "$@"
	local target_line="$1"
	local file="$2"
	local line
	local index=1
	while read line; do
		if [[ "$line" == "$target_line" ]]; then
			echo "$index"
			return 0
		fi
		index=$((index+1))
	done <"$playlist"
	echo "-1"
}

function output-success () {
	# unifying user success output
	# 1 argument: 
		# the string to output
	assert-opt-count "[SCRIPT-FAILURE] output-success" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local green="\e[1;32m"
	>&2 echo -e "${white}(${green}+${white}) ${output}"
}

function output-failure () {
	# unifying user failure output
	# 1 argument: 
		# the string to output
	assert-opt-count "[SCRIPT-FAILURE] output-failure" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local red="\e[1;31m"
	>&2 echo -e "${white}(${red}-${white}) ${output}"
}

function output-info () {
	# unfying user informative output
	# 1 argument: 
		# the string to output
	assert-opt-count "[SCRIPT-FAILURE] output-info" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local yellow="\e[1;33m"
	>&2 echo -e "${white}(${yellow}*${white}) ${output}"
}

function output-question () {
	# unifying user prompt output (used in is-confirmed)
	# 1 argument: 
		# the string to output
	assert-opt-count "[SCRIPT-FAILURE] output-question" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local blue="\e[1;34m"
	>&2 echo -ne "${white}(${blue}?${white}) ${output}"
}

function output-list () {
	assert-opt-count "[SCRIPT-FAILURE] output-list" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local purple="\e[1;35m"
	>&2 echo -e "${white}(${purple}~${white}) ${output} "

}

function items-clear () {
	assert-opt-count "[SCRIPT-FAILURE] items-clear" "==" 0 "$@"
	items_values=()
	items_ordered=()
}

function is-items-empty () {
	assert-opt-count "[SCRIPT-FAILURE] is-items-empty" "==" 0 "$@"
	if [[ "${items_ordered[@]}" == "" ]]; then
		return 0
	else
		return 1
	fi
}


function output-items () {
	# output every item in the global items associative array
	# return to execution flow on success, exit on failure
		# failure -> wrong func arg count
	# no arguments
	# this function should be found after show functions in the show man function.
	assert-opt-count "[SCRIPT-FAILURE] output-items" "==" 0 "$@"
	local item 
	for item in "${items_ordered[@]}"; do
		if [[ ${items_values["$item"]} -eq 1 ]] ; then
			output-list "\t$item"
		else
			output-list "[${items_values["$item"]}]\t$item "
		fi
	done
}

if ! [[ "${BASH_VERSINFO}" -ge 4 ]]; then
	output-failure "Current bash version ($BASH_VERSINFO) is not supported, please use bash version 4+ !"
	exit 1
fi
main "$@"
