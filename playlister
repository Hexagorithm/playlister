#!/bin/bash

# Hardcoded defaults
#	Immutable
main_directory="$HOME/.playlister/"
config_file="${main_directory}playlister.conf"
help_file="${main_directory}playlister.help"
playlist_ext=".plst"
mp3_ext=".mp3"
backup_ext=".bak"
tmp_file="/tmp/playlister-1234321.tmp"
#	Mutable
playlist_directory="${main_directory}playlists/"
mp3_directory="${main_directory}mp3s/"

declare -A configs=( 
	["main_directory"]="$main_directory" \
	["config_file"]="$config_file" \
	["help_file"]="$help_file" \
	["playlist_directory"]="$playlist_directory" \
	["mp3_directory"]="$mp3_directory" \
)

declare -a configs_mutable=(
	"mp3_directory" \
	"playlist_directory"
)

function main () {
	if [[ "$#" -eq 0 ]]; then
		output-failure "invalid argument count (must be > 0)"
		exit 1
	fi
	while [[ "$#" -gt 0 ]]; do
		case $1 in 
			config)
				shift
				config "$@"
				exit 0
				;;
			show)
				shift
				read-config-if-exists
				show "$@"
				exit 1
				;;
			*)
				output-failure "unrecognised option:\"$1\""
				shift
				exit 1
				;;
		esac
	done
}

function output-success () {
	# unifying user success output
	local output="$1"
	local white="\e[1;37m"
	local green="\e[1;32m"
	>&2 echo -e "${white}(${green}+${white}) ${output}."
}

function output-failure () {
	# unifying user failure output
	local output="$1"
	local white="\e[1;37m"
	local red="\e[1;31m"
	>&2 echo -e "${white}(${red}-${white}) ${output}!"
}

function output-info () {
	# unfying user informative output
	local output="$1"
	local white="\e[1;37m"
	local yellow="\e[1;33m"
	>&2 echo -e "${white}(${yellow}*${white}) ${output}."
}

function is-file-readable () {
	# check if file is readable
		# success -> file is readable
		# failure -> file is not readable
	# return to execution flow on success, exit on failure
	# 1 argument: the file
	if ! [[ $# -eq 1 ]]; then
		output-failure "invalid is-file-readable argument count(must be ==1)"
		exit 1
	fi
	local file="$1"
	file="${file%/}"	# trim slash if file given for when the file given is a directory.
	if ! [[ -r "$file" ]]; then
		output-failure "$file not readable"
		exit 1
	fi
}

function is-directory-not-empty () {
	# check if directory is empty
	# return to execution flow on success, exit on failure
		# success -> directory is not empty 
		# failure -> directory is empty
	# 1 argument: the directory
	if ! [[ $# -eq 1 ]]; then
		output-failure "invalid is-directory-empty argument count (must be ==1)"
		exit 1
	fi
	local directory="$1"

	if ! find "$directory" -mindepth 1 -maxdepth 1 | read; then
		output-failure "$directory is empty"
		exit 1
	fi
}



function show () {
	# extension of the program's main function for show options.
	if [[ $# -eq 0 ]]; then
		output-failure "invalid show argument count( must be >0)"
		exit 1
	fi
	declare -A items=()

	
	while ! [[ $# -eq 0 ]]; do
		case $1 in
			authors)
				shift
				show-authors "$@"
				output-items
				exit 0
				;;
			playlists)
				shift
				show-playlists "$@"
				output-items
				exit 0
				;;
			mp3s)
				shift
				show-mp3s "$@"
				output-items
				exit 0
				;;
			author)
				shift
				show-author "$@"
				output-items
				exit 0
				;;
			playlist)
				shift
				show-playlist "$@"
				output-items
				exit 1
				;;
			*)
				output-failure "unrecognised show option:\"$1\""
				exit 1
				;;
		esac
	done
}

function output-items () {
	# output every item in the global items associative array
	# return to execution flow on success, exit on failure
		# success -> items were outputted
		# failure -> function arguments were given
	# no arguments
	# this function should be found after show functions in the show man function.
	if ! [[ $# -eq 0 ]]; then
		output-failure "output-items takes in no arguments"
		exit 1
	fi

	local item 
	for item in "${!items[@]}"; do
		if [[ ${items["$item"]} -eq 1 ]] ; then
			echo -e "\t$item"
		else
			echo -e "\t$item \t[${items[$item]}]"
		fi
	done
}

function show-playlist () {
	# add every playlist entry to items
	# return code on execution on success , exit 1 on failure
		# success: all entries added to items
		# failure:
			# wrong argument count
			# playlist directory no exists / unreadable
			# playlist not readable
			# entry in playlist not valid, not to be deleted
	# 1 argument: playlist filename(basename'd)
	if ! [[ $# -eq 1 ]]; then
		output-failure "invalid show-playlist argument count(must be ==1)"
		exit 1
	fi
	local playlist="$1"

	is-file-readable "$playlist_directory"
	is-directory-not-empty "$playlist_directory"

	local playlist_path="${playlist_directory}${playlist}"
	is-file-readable "$playlist_path"
	
	is-file-readable "$mp3_directory"
	is-directory-not-empty "$mp3_directory"
	while read entry; do
		add-item "$entry"
	done <"$playlist_path"
}


function show-author () {
	# add every mp3 file name the <author> is author of to items
	# return execution flow on success, exit 1 on failure
		# succcess: all files were looped through and added to items accordingly
		# failure: 
			# mp3 directory not readable, 
			# mp3 directory empty, 
			# failed to add/increment author in items
	# implementation of playlist show author <author>
	# 1 argument: the name of the author
	if ! [[ $# -eq 1 ]]; then
		output-failure "invalid show-author argument count(must be ==1)"
		exit 1
	fi
	
	local target_author="$1"
	
	is-file-readable "$mp3_directory"
	
	is-directory-not-empty "$mp3_directory"

	local file
	for file in "$mp3_directory"*; do
		local filename="$(basename "$file")"
		local mp3name="$(get-from-filename "$filename" "mp3")"
		local authors="$(get-from-filename "$filename" "authors")" 	# split from full filename
		authors="$(divide-authors "$authors")" 				# divide from ", " to "|"
		IFS='|' read -ra authors <<< "$authors"				# split with '|'
		for author in "${authors[@]}"; do
			if [[ "$author" == "$target_author" ]]; then
				add-item "$mp3name"
			fi
		done
	done
}

function show-authors () {
	# add every author in mp3 directory to items with their respective number of "author'ed" files
	# return execution flow on success, exit 1 on failure
		# succcess: all files were looped through and added to items accordingly
		# failure: 
			# mp3 directory not readable, 
			# mp3 directory empty, 
			# failed to add/increment author in items
	# implementation of playlist show authors
	# no arguments
	if [[ $# -ne 0 ]]; then
		output-failure "show-authors does not take any arguments"
		exit 1
	fi
	is-file-readable "$mp3_directory"

	is-directory-not-empty "$mp3_directory"
	local file
	for file in "$mp3_directory"*; do
		local filename="$(basename "$file")"
		local mp3name="$(get-from-filename "$filename" "mp3")"
		local authors="$(get-from-filename "$filename" "authors")" 	# split from full filename
		authors="$(divide-authors "$authors")" 				# divide from ", " to "|"
		IFS='|' read -ra authors <<< "$authors"				# split with '|'
		for author in "${authors[@]}"; do
			add-item "$author"
		done

	done
}

function show-mp3s () {
	# adds every mp3 file to items
	# return execution flow on success, exit 1 on failure
		# success: all files were looped and added to items
		# failures:
			# wrong arg count
			# arg not in ["all", "used", "unused"]
			# mp3 directory not readable
			# mp3 directory empty
			# is-mp3-used fail
	# 1 argument: type of mp3: ["all", "used", "unused"]
	# implementation of playlister show mp3 <type>
	if [[ $# -ne 1 ]]; then
		output-failure "invalid show-mp3 argument count (must be ==1)"
		exit 1
	fi
	local argument="$1"
	
	if ! (  [[ "$argument" == "all" ]] 	|| \
		[[ "$argument" == "used" ]] 	|| \
		[[ "$argument" == "unused" ]] 	); then
		output-failure "invalid show-mp3 argument:\"$argument\""
		exit 1
	fi
	
	is-file-readable "$mp3_directory"
	is-directory-not-empty "$mp3_directory"
	local file
	for file in "${mp3_directory}"*; do
		filename="$(basename "$file" )"

		if [[ "$argument" == "all" ]]; then
			add-item "$filename"

		elif [[ "$argument" == "used" ]]; then
			if is-mp3-used "$filename"; then
				add-item "$filename"
			fi

		else #unused
			if ! is-mp3-used "$filename"; then
				add-item "$filename"
			fi
		fi
	done
}

function is-mp3-used () {
	# checks if mp3 file is entry in a playlist
	# return int status as value, exit 1 on error
		# success: return status
			# 0 -> mp3 is used
			# 1 -> mp3 is not used
		# failure:
			# wrong arg count
			# playlist directory not readable
			# playlist directory empty
			# playlist file not readable
	# 1 argument: filename to be checked (previously basename'd!)
	# used in show-mp3 with mp3 type distinctions
	if [[ $# -ne 1 ]]; then
		output-failure "invalid is-mp3-used argument count(must be ==1)"
		exit 1
	fi
	local filename="$1"
	
	is-file-readable "$playlist_directory"

	is-directory-not-empty "$playlist_directory"

	local playlist
	for playlist in "${playlist_directory}"* ; do
		is-file-readable "$playlist"
		local line
		while read line; do
			if [[ "$line" == "$filename" ]]; then
				return 0
			fi
		done <"$playlist"
	done
	return 1
}

function show-playlists () {
	# add every playlist to items
	# return execution flow if success, exit 1 if failure
		# success: all playlists added to items
		# failure:
			# wrong arg count
			# playlist directory unreadable
			# playlist directory empty
			# add-item exits
	# no arguments
	# implementation of playlister show playlists
	if [[ $# -ne 0 ]]; then
		output-failure "show-playlists does not take any arguments"
		exit 1
	fi
	is-file-readable "$playlist_directory"

	is-directory-not-empty "$playlist_directory"
	for file in "${playlist_directory}"* ; do
		local filename="$(basename "$file")"
		add-item "$filename"
	done
}

function is-item-inside-items () {
	if ! [[ $# -eq 1 ]]; then
		output-failure "invalid is-item-inside-items argument count (must be ==1)"
		exit 1
	fi
	local argument="$1"
	local item
	for item in "${!items[@]}"; do
		if [[ "$argument" == "$item" ]]; then
			return 0
		fi 
	done
	return 1
}

function get-from-filename () {
	
	if ! [[ $# -eq 2 ]]; then
		output-failure "invalid get-from-filename argument count (must be ==2)"
		exit 1
	fi
	
	local filename="$1"
	local option="$2"
	if ! ( [[ "$option" == "mp3" ]] || [[ "$option" == "authors" ]] ) ; then
		output-failure "invalid get-from-filename option:\"$option\""
		exit 1
	fi
	
	local separator=" - "
	local tmp=${filename//"$separator"/$'\2'}
	local authors
	local mp3
	IFS=$'\2' read authors mp3 <<< "$tmp"
	
	if [[ "$option" == "authors" ]]; then
		echo "$authors"
	else
		echo "$mp3"
	fi
}

function divide-authors (){
	if ! [[ $# -eq 1 ]]; then
		output-failure "invalid divide-authors argument count (must be ==1)"
		exit 1
	fi
	local authors_string="$1"
	local separator=", "
	local authors=${authors_string//"$separator"/'|'}
	echo "$authors"
	
}

function add-item () {
	# add string item to items with initalized count, or if already exists: increase counter.
	# return to execution flow on success, exit on failure
		# success -> item added 
		# failure -> invalid argument count
	# 1 argument: string item to be added 
	if ! [[ $# -eq 1 ]]; then
		output-failure "invalid add-item argument count(must be ==1)"
		exit 1
	fi
	local new_item="$1"
	if is-item-inside-items "$new_item"; then
		items["$new_item"]=$(( ${items["$new_item"]} + 1 ))
	else
		items["$new_item"]=$(( 1 ))
	fi
}

function config () {
	if [[ "$#" -eq 0 ]]; then
		output-failure "invalid config argument count (must be >0)"
		exit 1
	fi
	while [[ "$#" -gt 0 ]]; do
		case $1 in
			configure)
				config-configure
				exit 0
				;;
			list)
				read-config-if-exists
				config-list
				exit 0
				;;
			get)
				shift
				read-config-if-exists
				config-get "$@"
				exit 0
				;;
			set)	
				shift
				read-config-if-exists
				config-set "$@"
				exit 0
				;;
			*)
				output-failure "unrecognised config option:\"$1\""
				exit 1
				;;
		esac
	done
}
function config-configure () {
	if ! create-directory "$main_directory" ; then
		exit 1
	fi
	
	if ! setup-file "$help_file" "currentdir"; then
		exit 1
	fi
	
	if ! setup-file "$config_file" "backup" "makenew"; then
		exit 1
	fi
	
	if read-config ; then
		output-success "$(basename "$config_file") read"
	else
		output-failure "$(basename "$config_file") failed to read"
		exit 1
	fi
	
	if ! create-directory "$mp3_directory"; then
		exit 1
	fi

	if ! create-directory "$playlist_directory"; then
		exit 1
	fi
}

function config-list () {

	for configuration in "${!configs[@]}"; do
		# i do not need to check for validity of $configuration here
		# for $configuration is fetched directly from $configs
		if ! get-config "$configuration"; then
			output-failure "$configuration failed to list"
			exit 1
		fi
	done
}

function config-get () {
	if [[ $# -ne 1 ]]; then
		output-failure "invalid config get argument count(must be ==1)"
		exit 1
	fi
	local argument="$1"
	if ! is-valid-config "$argument" ; then
		output-failure "not a valid configuration: \"$argument\""
		return 1
	fi
	get-config "$argument"
}

function config-set () {
	if [[ $# -ne 2 ]]; then
		output-failure "invalid config set argument count(must be ==2)"
		exit 1
	fi
	
	local config_file_name="$( basename "$config_file" )"
	
	if ! [[ -w "$config_file" ]]; then
		output-failure "$config_file_name is not writable"
		exit 1
	fi
	
	> "$tmp_file"
	if ! [[ $? -eq 0 ]]; then
		output-failure "failed to create a file in /tmp"
		exit 1
	fi
	
	local argument="$1"
	if ! is-valid-config-mutable "$argument"; then
		output-failure "not a valid mutable configuration:\"$argument\""
		exit 1
	fi
	
	if ! change-configs-to-tmp "$@"; then
		output-failure "failed to change configs"
		exit 1
	fi
	
	cp "$tmp_file" "$config_file"
	if ! [[ $? -eq 0 ]]; then
		output-file "failed to overwrite $config_file_name with tmp file"
		exit 1
	fi
}

function create-directory () {
	local directory="$1"
	local directoryname="$(basename "$1")"
	if [[ -d "$directory" ]]; then
		output-info "$directoryname exists"
	else
		mkdir $directory
		if [[ $? -ne 0 ]]; then
			output-failure "$directoryname failed to create"
			return 1
		else
			output-success "$directoryname created"
		fi
		
	fi
	return 0
}

function setup-file () {
	local filepath="$1"
	local filename="$( basename "$filepath" )"
	local backup="no"
	local currentdir="no"
	local makenew="no"
	shift
	while [[ "$#" -ne 0 ]]; do
		case $1 in 
			"backup")
				backup="yes"
				shift
				;;
			"currentdir")
				currentdir="yes"
				shift
				;;
			"makenew")
				makenew="yes"
				shift
				;;
			*)
				output-failure "unrecognised setup-file option:\"$1\""
				return 1
				;;
		esac
	done
	
	if [[ -a "$filepath" ]]; then
		output-info "$filename exists"
		return 0
	fi
	output-info "$filename does not exist"

	if [[ "$backup" == "yes" ]]; then
		local filepathbak="${filepath}${backup_ext}"
		if [[ -a "$filepathbak" ]]; then
			cp "$filepathbak" "$filepath"
			if [[ $? -eq 0 ]]; then
				output-success "$filename created from backup"
				return 0
			else
				output-failure "$filename failed to create from backup"
			fi
		else
			output-info "$filename has no backup"
		fi
	fi

	if [[ "$currentdir" == "yes" ]]; then
		if [[ -a  "$filename" ]]; then
			mv "$filename" "$filepath"
			if [[ $? -eq 0 ]]; then
				output-success "$filename fetched from current directory"
				return 0
			else
				output-failure "$filename failed to fetch from current directory"
			fi
		else
			output-info "$filename not found in current directory"
		fi
	fi

	if [[ "$makenew" == "yes" ]]; then
		touch "$filepath"
		if [[ $? -eq 0 ]]; then
			output-success "$filename created"
			return 0
		fi
		output-failure "$filename failed to create"
	fi
	
	output-failure "$filename setup failed"
	return 1
}

function read-config () {
	is-file-readable "$config_file"
	while read line ; do
		local argument="$(echo "$line" | cut -d "=" -f 1)"
		case "$argument" in
			"mp3_directory")
				local value="$(echo "$line" | cut -d "=" -f 2)"
				mp3_directory="$value"
				configs["mp3_directory"]="$value"
				;;
			"playlist_directory")
				local value="$(echo "$line" | cut -d "=" -f 2)"
				playlist_directory="$value"
				configs["playlist_directory"]="$value"
				;;
			*)
				output-failure "not valid user config: \"$argument\""
				return 1
				;;
		esac
	done < "$config_file"
}

function read-config-if-exists () {
	
	local config_file_name="$(basename "$config_file")"
	if ! [[ -a "$config_file" ]]; then
		output-failure "$config_file_name does not exist"
		exit 1
	fi

	if ! read-config; then
		output-failure "$config_file_name failed to read"
		exit 1
	fi
}

function is-valid-config (){
	local argument="$1"
	local configuration
	for configuration in "${!configs[@]}"; do
		if [[ "$configuration" == "$argument" ]]; then
			return 0
		fi
	done
	return 1
}

function change-configs-to-tmp () {
	local config="$1"
	local value="$2"
	local found="no"
	local line
	while read line; do
		if [[ "$(echo "$line" | cut -d "=" -f 1)" == "$config" ]]; then
			echo "${config}=${value}" >> "$tmp_file"
			found="yes"
		else
			echo "$line" >> "$tmp_file"
		fi
	done < "$config_file"
	if [[ "$found" == "no" ]]; then
		echo "${config}=${value}" >> "$tmp_file"
	fi
}

function is-valid-config-mutable () {
	local argument="$1"
	local configuration
	for configuration in "${configs_mutable[@]}"; do
		if [[ "$argument" == "$configuration" ]]; then
			return 0
		fi
	done
	return 1
	
}

function get-config () {
    local argument="$1"
    output-info "	$argument	-> 	${configs[$argument]} "
}

main "$@"
