#!/bin/bash

# Hardcoded defaults
	# Immutable
DIR_MAIN="$HOME/.playlister/"
FILE_CONFIG="${DIR_MAIN}playlister.conf"
FILE_HELP="${DIR_MAIN}playlister.help"
EXT_PLAY=".plst"
EXT_MP3=".mp3"
EXT_BKUP=".bak"
SEP_POLI_AUTHOR_AUTHOR=", "			# this points to separator dividing the authors from eachother
SEP_POLI_AUTHORS_MP3=" - "			# this points to separator dividing the authors and the mp3 name
SEP_MONO="|"					# SEP_POLI separators are mutated to this for easier processing
USER_INPUT=":"
	# Mutable
DIR_PLAY="${DIR_MAIN}playlists/"
DIR_MP3S="${DIR_MAIN}mp3s/"

declare -A CONFIG_VALUES=(
	["DIR_MAIN"]="$DIR_MAIN" 	\
	["FILE_CONFIG"]="$FILE_CONFIG" 	\
	["FILE_HELP"]="$FILE_HELP" 	\
	["DIR_PLAY"]="$DIR_PLAY" 	\
	["DIR_MP3S"]="$DIR_MP3S"
)

declare -a CONFIGS_ALL=(
	"DIR_MAIN" 	\
	"FILE_CONFIG" 	\
	"FILE_HELP" 	\
	"DIR_PLAY"	\
	"DIR_MP3S"
)

declare -a CONFIGS_MUTABLE=(
	"DIR_MP3S" \
	"DIR_PLAY"
)

function main () {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "main" ">" 0 "$@"
	while [[ "$#" -gt 0 ]]; do
		case $1 in 
			config)
				shift
				config "$@"
				exit 0
				;;
			show)
				shift
				assert-file-exists 	"$FILE_CONFIG"
				assert-file-readable 	"$FILE_CONFIG"
				read-config
				show "$@"
				exit 0
				;;
			playlist)
				shift
				assert-file-exists 	"$FILE_CONFIG"
				assert-file-readable 	"$FILE_CONFIG"
				read-config
				playlist "$@"
				exit 0
				;;
			check)
				shift
				assert-file-exists 	"$FILE_CONFIG"
				assert-file-readable 	"$FILE_CONFIG"
				read-config
				check "$@"
				exit 0
				;;
			*)
				output-failure "unrecognised option:\"$1\""
				shift
				exit 1
				;;
		esac
	done
}

function playlist() {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "playlist" ">" 0 "$@"
	declare -A items=()
	while ! [[ $# -eq 0 ]]; do
		case $1 in 
			add)
				shift 
				playlist-add "$@"
				output-items
				exit 0	
				;;
			play)
				shift
				playlist-play "$@"
				output-items
				exit 0
				;;
			del)
				shift
				playlist-del "$@"
				output-items
				exit 0
				;;
			create)
				shift
				playlist-create "$@"
				output-items
				exit 0
				;;
			destroy)
				shift
				playlist-destroy "$@"
				output-items
				exit 0
				;;
			copy)
				shift
				playlist-copy "$@"
				output-items
				exit 0
				;;
			*)
				output-failure "\"$1\" unrecognized playlist option"
				exit 1
				;;
		esac

	done
}

function check() {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "check" ">" 0 "$@"
	declare -A items=()
	while ! [[ $# -eq 0 ]]; do
		case $1 in
			mp3s | playlists )
				check-files "$@"
				output-items
				exit 0
				;;
			playlist)
				shift
				check-playlist "$@"
				output-items
				exit 0
				;;
			*)
				output-failure "\"$1\" unrecognized check option"
				exit 1
				;;
		esac

	done
}

function check-playlist() {
	# checks if every entry in playlist is an existing mp3 file
	assert-arg-count "check-playlist" "==" 1 "$@"
	local playlistname="$1"

	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable		"$DIR_MP3S"
	assert-directory-not-empty	"$DIR_MP3S"

	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable		"$DIR_PLAY"
	assert-directory-not-empty	"$DIR_PLAY"

	local playlist="${DIR_PLAY}${playlistname}"
	assert-file-exists 		"$playlist"
	assert-file-readable		"$playlist"

	local entry
	while read -u 69 entry; do
		local mp3file="${DIR_MP3S}${entry}"
		if is-file-exists "$mp3file"; then
			output-success "\"$entry\" reffers to existing file"
			continue
		fi

		output-failure "\"$entry\" does not reffer to existing file"
		if is-confirmed "Rename \"$entry\""; then
			assert-file-writable 	"$DIR_MP3S"
			assert-file-writable 	"$playlist"
			local user
			while : ; do
				output-info "Give new file name of \"$entry\""
				user="$(get-user-input)"
				if 	! is-string-valid-mp3name "$user"; then
					output-failure "\"$user\" invalid mp3 file name"
					continue
				elif 	! is-file-exists "${DIR_MP3S}${user}"; then
					output-failure "\"$user\" does reffer to existing mp3 file"
					continue
				fi
				break
			done
			local linecount=1
			while read -u 68 line; do
				if [[ "$line" == "$entry" ]]; then
					sed -i "${linecount}s/$entry/$user/" "$playlist"
					break
				fi
				linecount=$((linecount + 1))
			done 68< "$playlist"
			output-success "\"$entry\" changed to \"$user\""
		elif is-confirmed "Delete \"$entry\""; then
			assert-file-writable 	"$playlist"
			local linecount=1
			while read -u 68 line; do
				if [[ "$line" == "$entry" ]]; then
					sed -i "${linecount}d" "$playlist"
					break
				fi
				linecount=$((linecount + 1))
			done 68< "$playlist"
			output-success "\"$entry\" deleted"
		fi

	done 69< "$playlist"



}

function check-files() {
	# checks if every file  is formatted according to its type
	# Asumption: keyword given is a valid keyword "playlists" or "mp3s"
	# 1 keyword argument -> "playlists" or "mp3s"

	assert-arg-count "check-files" "==" 1 "$@"
	local keyword="$1"

	local directory
	if [[ "$keyword" == "playlists" ]]; then	directory="$DIR_PLAY"
	else						directory="$DIR_MP3S"
	fi

	assert-file-exists 		"$directory"
	assert-file-readable 		"$directory"
	assert-directory-not-empty	"$directory"

	local file
	for file in "${directory}"*; do
		local filename="$(basename "$file" )"
		local isvalid

		if [[ "$keyword" == "playlists" ]]; then
			if 	is-string-valid-playlist "$filename"; then 	isvalid=0
			else							isvalid=1
			fi
		else # mp3s
			if is-string-valid-mp3name "$filename"; then		isvalid=0
			else 							isvalid=1
			fi
		fi

		if [[ $isvalid -eq 0 ]]; then
			output-success "\"$filename\" valid ${keyword%s}"	# delete s from keyword
			continue
		fi
		output-failure "\"$filename\" invalid ${keyword%s}"		

		if ! is-confirmed "Rename \"$filename\""; then
			continue
		fi

		assert-file-writable "$directory"

		local user
		while : ; do
			output-info "Give new name of \"$filename\""
			user="$(get-user-input)"
			local isvalid
			if [[ "$keyword" == "playlists" ]]; then
				if is-string-valid-playlist "$user"; then	isvalid=0
				else						isvalid=1
				fi
			else # mp3s
				if is-string-valid-mp3name "$user"; then	isvalid=0
				else						isvalid=1
				fi
			fi
			if   [[ $isvalid -eq 1 ]]; then
				output-failure "\"$user\" invalid ${keyword%s} name"
				continue
			elif is-file-exists "${directory}${user}"; then
				output-failure "\"$user\" ${keyword%s} exists"
				continue
			fi
			break
		done
		mv "$file" "${directory}${user}"
		output-success "Renamed \"$filename\" to \"$user\""
	done
}

function is-string-valid-playlist() {
	# does not validate user string propelly(slashes), oh well!
	assert-arg-count "is-string-valid-playlist" "==" 1 "$@"
	local playlistname="$1"
	if !	[[ "$playlistname" == *"${EXT_PLAY}" ]]; then
		return 1
	fi
	return 0

}

function is-string-valid-mp3name () {
	# does not validate user string propelly(slashes), oh well!
	assert-arg-count "is-string-valid-mp3name" "==" 1 "$@"
	local mp3name="$1"
	local authors="$(get-from-filename "$mp3name" "authors")"
	if [[ "$authors" == "" ]]; then
		return 1
	fi

	local mp3name="$(get-from-filename "$mp3name" "mp3")"
	if 	[[ "$mp3name" == "" ]]; then
		return 1
	elif	! [[ "$mp3name" == *"${EXT_MP3}" ]]; then
		return 1
	fi
	return 0

}

function get-user-input() {
	assert-arg-count "get-user-input" "==" 0 "$@"
	local user
	read -p "${USER_INPUT}" user
	echo "$user"

}

function playlist-play () {
	# for entry in playlist given, give it to mpg123 program for playing
	# exit 1 on failure
		# failure:
			# wrong arg count
			# playlist directory does not exist, is unreadable, is empty
			# playlist file does not exist, is unreadable
			# mp3 directory does not exist, is unreadable, is empty
			# mpg123 failed to play mp3 file
	# 1 argument
		# the basenamed name of the playlist
		# keyword for the order in which mp3 files should be outputted
	assert-arg-count "playlist-play" "==" 2 "$@"
	local playlistname="$1"
	local keyword="$2"

	local valid_keywords=( "random" "original" )



	if ! is-element-in-array "$keyword" "valid_keywords" ;then 
		output-failure "\"$keyword\" is not a valid playlist-play keyword"
		exit 1
	fi


	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable 		"$DIR_PLAY"
	assert-directory-not-empty 	"$DIR_PLAY"

	local playlist="${DIR_PLAY}${playlistname}"
	assert-file-exists 		"$playlist"
	assert-file-readable 		"$playlist"

	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty 	"$DIR_MP3S"

	local entry

	local tmpfile=$(mktemp /tmp/playlister-temp.XXXXXX)
	exec 3>"$tmpfile"
	exec 4<"$tmpfile"
	
	if 	[[ "$keyword" == "random" ]]; then
		echo "$(cat "$playlist" | sort -R )" 	>&3
	elif 	[[ "$keyword" == "original" ]]; then
		echo "$(cat "$playlist" )" 		>&3
	else
		output-failure "\"$keywordl\" rouge keyword caught"
		exit 1
	fi

	local lastnumber="$(cat "$tmpfile" | wc -l )"
	local currnumber=1

	while read entry; do
		local mp3="${DIR_MP3S}${entry}"
		output-info "Playing(${currnumber}/${lastnumber}): $entry"
		mpg123 "$mp3" 2> /dev/null 
		if ! [[ $? -eq 0 ]]; then
			output-failure "mpg123 failed to play \"$entry\""
			exit 1
		fi
		currnumber=$(( currnumber + 1 ))
	done <&4
}

function playlist-add() {
	# to playlist, add every mp3 file that is valid and not an entry, also add them to items
	# exit 1 on failure
		# failures:
			# wrong arg count
			# playlist directory does not exist, not readable, or empty
			# playlist file does not exist, not readable, not writable
			# mp3 directory does nto exist, not readable, or empty
	# 2 arguments;
		# 1) 	basenamed playlist filename
		# 2..)  basenamed mp3files to add
	assert-arg-count "playlist-add" ">" 1 "$@"
	local playlistname="$1"
	shift

	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable 		"$DIR_PLAY"
	assert-directory-not-empty 	"$DIR_PLAY"

	local playlist="${DIR_PLAY}${playlistname}"

	assert-file-exists 	"$playlist"
	assert-file-readable 	"$playlist"
	assert-file-writable 	"$playlist"

	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty	"$DIR_MP3S"


	while ! [[ $# -eq 0 ]]; do
		local entry="$1"
		shift
		assert-file-exists "${DIR_MP3S}${entry}"

		if is-line-in-file "$entry" "$playlist"; then
			output-failure "\"$entry\" already in \"$playlistname\""
			continue
		fi
		echo "$entry" >> "$playlist"

		add-item "$entry"
	done
}

function playlist-del() {
	# delete every instance of mp3 names given in playlist
		# exit 1 on failure
			# failure:
				# DIR_PLAY does not exist, not readable, or empty
				# given playlist does not exist, unreadable or unwritable
				# DIR_MP3S does not exist, not readable or empty
	# arguments:
		# 1) basenamed playlist name
		# 2...)  basenamed mp3 file name
	assert-arg-count "playlist-del" ">" 1 "$@"
	local playlistname="$1"
	shift

	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable 		"$DIR_PLAY"
	assert-directory-not-empty 	"$DIR_PLAY"

	local playlist="${DIR_PLAY}${playlistname}"

	assert-file-exists 	"$playlist"
	assert-file-readable 	"$playlist"
	assert-file-writable 	"$playlist"

	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty	"$DIR_MP3S"


	while ! [[ $# -eq 0 ]]; do
		local entry="$1"
		shift
		assert-file-exists "${DIR_MP3S}${entry}"

		if ! is-line-in-file "$entry" "$playlist"; then
			output-failure "\"$entry\" not in \"$playlistname\""
			continue
		fi
		sed -i "/^${entry}/d" "$playlist"
		add-item "$entry"
	done
}

function playlist-create() {
	# create a new blank playlist of the given name
		# exit 1 on failure
			# failure:
				# DIR_PLAY does not exists, unreadable, unwritable 
				# playlist of the given name already exists
	# 1 argument:
		# the basenamed name of the playlist
	assert-arg-count "playlist-create" "==" 1 "$@"
	local playlistname="$1"

	# DiR_PLAY should not fail to create playlist even if playlist is empty
	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable		"$DIR_PLAY"
	assert-file-writable 		"$DIR_PLAY"

	local playlist="${DIR_PLAY}${playlistname}"

	if is-file-exists "$playlist"; then
		output-failure "\"$playlistname\" exists"
		exit 1
	fi
	touch "$playlist"
}

function playlist-destroy() {
	# delete an existing playlist of given name
		# exit 1 on failure
			# failure:
				# DIR_PLAY does not exists, unreadable, unwritable 
				# playlist of the given name does not exist
	# 1 argument:
		# the basenamed name of the playlist
	assert-arg-count "playlist-destroy" "==" 1 "$@"
	local playlistname="$1"

	# DiR_PLAY should not fail to playlist even if playlist is empty
	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable		"$DIR_PLAY"
	assert-directory-not-empty	"$DIR_PLAY"
	assert-file-writable 		"$DIR_PLAY"

	local playlist="${DIR_PLAY}${playlistname}"

	if ! is-file-exists "$playlist"; then
		output-failure "\"$playlistname\" does not exist"
		exit 1
	fi
	rm "$playlist"
}

function playlist-copy() {
	# copy an existing given playlist into a new playlist of given new name
		# exit 1 on failure
			# DIR_PLAY does not exist, unreadable, empty, unwritable
			# existiing playlist does not exist
			# new playlist already exists
	# 2 arguments
		# 1) existing playlist
		# 2) new playlist
	assert-arg-count "playlist-copy" "==" 2 "$@"
	local existplaylistname="$1"
	local newplaylistname="$2"

	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable		"$DIR_PLAY"
	assert-directory-not-empty	"$DIR_PLAY"
	assert-file-writable 		"$DIR_PLAY"

	local existplaylist="${DIR_PLAY}${existplaylistname}"
	local newplaylist="${DIR_PLAY}${newplaylistname}"


	if ! is-file-exists "$existplaylist"; then
		output-failure "\"$existplaylistname\" does not exist"
		exit 1
	fi

	if is-file-exists "$newplaylist"; then
		output-failure "\"$newplaylistname\" exists"
		exit 1
	fi
	cp "$existplaylist" "$newplaylist"
}

function show () {
	# extension of the program's main function for show options.
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "show" ">" 0 "$@"
	declare -A items=()
	
	while ! [[ $# -eq 0 ]]; do
		case $1 in
			authors)
				shift
				assert-arg-count "show-authors" "<" 2 "$@"
				if 	[[ $# -eq 0 ]]; then
					show-authors "$@"
				elif 	[[ $# -eq 1 ]]; then
					show-authors-of-mp3 "$@"
				fi
				output-items
				exit 0
				;;
			playlists)
				shift
				show-playlists "$@"
				output-items
				exit 0
				;;
			mp3s)
				shift
				show-mp3s "$@"
				output-items
				exit 0
				;;
			author)
				shift
				show-author "$@"
				output-items
				exit 0
				;;
			playlist)
				shift
				show-playlist "$@"
				output-items
				exit 0
				;;
			mp3)
				shift
				show-mp3 "$@"
				output-items
				exit 0
				;;
			*)
				output-failure "unrecognised show option:\"$1\""
				exit 1
				;;
		esac
	done
}

function show-mp3 () {
	# add every playlist to items, if playlist has $mp3name
	# return execution on success, ext 1 on failure
		# failure:
			# wrong arg count
			# DIR_MP3S does not exist, is unreadable or is empty
			# mp3name does not point to an existing mp3 file
			# DIR_PLAY does not exist, is unreadable or is empty
			# a playlist file is unreadable
	# 1 argument:
		# basenamed filename of the mp3 file
	assert-arg-count "show-mp3" "==" 1 "$@"
	local mp3name="$1"

	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty 	"$DIR_MP3S"

	local mp3="${DIR_MP3S}${mp3name}"

	assert-file-exists 		"$mp3"

	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable 		"$DIR_PLAY"
	assert-directory-not-empty 	"$DIR_PLAY"		

	for file in "${DIR_PLAY}"*; do
		local filename="$(basename "$file" )"
		assert-file-readable "$file"
		if is-line-in-file "$mp3name" "$file"; then
			add-item "$filename"
		fi
	done
}

function show-playlist () {
	# add every playlist entry to items
	# return code on execution on success , exit 1 on failure
		# failure:
			# wrong argument count
			# mp3 directory does not exist, unreadable or empty
			# playlistname points to a nonexistant mp3 file
			# playlist directory does not exist, unreadable, or empty
	# 1 argument: 
		# playlist filename(basename'd)
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "show-playlist" "==" 1 "$@"
	local playlistname="$1"

	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable 		"$DIR_PLAY"
	assert-directory-not-empty 	"$DIR_PLAY"

	local playlist="${DIR_PLAY}${playlistname}"
	assert-file-exists 		"$playlist"
	assert-file-readable 		"$playlist"

	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty 	"$DIR_MP3S"
	while IFS= read -ru 69 entry; do
		add-item "$entry"
	done 69<"$playlist"
}

function is-confirmed () {
	# get user yes, no input to make simple script decisions
	# return 0 if confirmed, return 1 if rejected, exit 1 on error
		# failures: wrong arg count
	# 1 argument: string prompt to display
	assert-arg-count "is-confirmed" "==" 1 "$@"
	local prompt="$1"

	local confirmation=( "y" "ye" "yes" "Y" "Ye" "Yes" "YE" "YES" )
	local rejection=("n" "no" "N" "No" "NO" )
	while : ; do
		output-question "$prompt"
		local user="$(get-user-input)"
		local option
		if is-element-in-array "$user" "confirmation"; then
			return 0
		elif is-element-in-array "$user" "rejection"; then
			return 1
		fi

		output-info "Invalid user input: \"$user\""
	done
}



function show-author () {
	# add every mp3 file name the <author> is author of to items
	# return execution flow on success, exit 1 on failure
		# failure: 
			# wrong arg count
			# DIR_MP3S does not exist, is unreadable or empty
	# 1 argument: 
		# the name of the author
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "show-author" "==" 1 "$@"
	local target_author="$1"
	
	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty 	"$DIR_MP3S"

	local file
	for file in "$DIR_MP3S"*; do
		local filename="$(basename "$file")"
		local mp3name="$(get-from-filename "$filename" "mp3")"
		local authors="$(get-from-filename "$filename" "authors")" 	# split from full filename
		authors="$(divide-authors "$authors")" 				# divide from SEP_POLI_AUTHOR_AUTHOR to SEP_MONO
		IFS="${SEP_MONO}" read -ra authors <<< "$authors"				# split with SEP_MONO
		for author in "${authors[@]}"; do
			if [[ "$author" == "$target_author" ]]; then
				add-item "$mp3name"
			fi
		done
	done
}

function show-authors () {
	# add every author in mp3 directory to items with their respective number of "author'ed" files
	# return execution flow on success, exit 1 on failure
		# failure: 
			# DIR_MP3S does not exist, unreadable or empty
			# failed to add/increment author in items
	# no arguments

	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "show-authors" "==" 0 "$@"

	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty 	"$DIR_MP3S"
	local file
	for file in "$DIR_MP3S"*; do
		local filename="$(basename "$file")"
		local mp3name="$(get-from-filename "$filename" "mp3")"
		local authors="$(get-from-filename "$filename" "authors")" 	# split from full filename
		authors="$(divide-authors "$authors")" 				# divide from SEP_POLI_AUTHOR_AUTHOR to SEP_MONO
		IFS="${SEP_MONO}" read -ra authors <<< "$authors"		# split with SEP_MONO 
		for author in "${authors[@]}"; do
			add-item "$author"
		done

	done
}

function show-authors-of-mp3 () {
	# adds every author in mp3 directory that is author of mp3 file which name is <mp3>
	# return execution flow n success, exit 1 on failure
		# failure:
			# wrong arg count
			# mp3 directory does not exist, is unreadable or empty
	# 1 argument:
		# the target mp3 file name (without authors, with mp3 extension)
	assert-arg-count "show-authors-of-mp3" "==" 1 "$@"
	local target_mp3name="$1"


	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty 	"$DIR_MP3S"
	local file
	for file in "$DIR_MP3S"*; do
		local filename="$(basename "$file" )"
		local mp3name="$(get-from-filename "$filename" "mp3")"
		if [[ "$mp3name" == "$target_mp3name" ]]; then
			local authors="$(get-from-filename "$filename" "authors")"
			authors="$(divide-authors "$authors")"
			IFS="${SEP_MONO}" read -ra authors <<< "$authors"
			for author in "${authors[@]}"; do
				add-item "$author"
			done
		fi

	done
}

function show-mp3s () {
	# adds every mp3 file to items
	# return execution flow on success, exit 1 on failure
		# success: all files were looped and added to items
		# failures:
			# wrong arg count
			# arg not in ["all", "used", "unused"]
			# mp3 directory not readable
			# mp3 directory empty
			# is-mp3-used fail
	# 1 argument: type of mp3: ["all", "used", "unused"]
	# implementation of playlister show mp3 <type>

	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "show-mp3s" "==" 1 "$@"
	local keyword="$1"
	local valid_keywords=( "all" "used" "unused")
	if ! is-element-in-array "$keyword" "valid_keywords"; then
		output-failure "\"$keyword\" is not inside \"${valid_keywords[*]}\""
		exit 1
	fi
	
	assert-file-exists 		"$DIR_MP3S"
	assert-file-readable 		"$DIR_MP3S"
	assert-directory-not-empty 	"$DIR_MP3S"
	local file

	for file in "${DIR_PLAY}"*; do		# playlist check for is-mp3-used
		assert-file-readable "$file"
	done

	for file in "${DIR_MP3S}"*; do
		local filename="$(basename "$file" )"
		case "$keyword" in
			"all")
				add-item "$filename"
				;;
			"used")
				if is-mp3-used "$filename"; then
					add-item "$filename"
				fi
				;;
			"unused")
				if ! is-mp3-used "$filename"; then
					add-item "$filename"
				fi
				;;
			*)
				output-failure "how did \"$keyword\" slip through the argument check?"
		esac
	done
}

function is-mp3-used () {
	# checks if mp3 file is entry in a playlist
	# Assumption: 
			# DIR_PLAY exists, readable and not empty, 
			# every playlist is readable
	# return int status as value, exit 1 on error
		# success: return status
			# 0 -> mp3 is used
			# 1 -> mp3 is not used
		# failure:
			# wrong arg count
	# 1 argument: 
		# filename to be checked (previously basename'd!)
	assert-arg-count "is-mp3-used" "==" 1 "$@"
	local filename="$1"
	
	local playlist
	for playlist in "${DIR_PLAY}"* ; do
		local line
		if is-line-in-file "$filename" "$playlist"; then
			return 0
		fi
	done
	return 1
}

function show-playlists () {
	# add every playlist to items
	# return execution flow if success, exit 1 if failure
		# success: all playlists added to items
		# failure:
			# wrong arg count
			# playlist does not exits, unreadable or empty
	# no arguments

	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "show-playlists" "==" 0 "$@"

	assert-file-exists 		"$DIR_PLAY"
	assert-file-readable 		"$DIR_PLAY"
	assert-directory-not-empty 	"$DIR_PLAY"

	for file in "${DIR_PLAY}"* ; do
		local filename="$(basename "$file")"
		add-item "$filename"
	done
}

function get-from-filename () {
	
	assert-arg-count "get-from-filename" "==" 2 "$@"
	
	local filename="$1"
	local keyword="$2"

	local valid_keywords=( "mp3" "authors" )

	if ! is-element-in-array "$keyword" "valid_keywords"; then
		output-failure "\"$keyword\" not in: \"${valid_keywords[*]}\""
		exit 1
	fi

	local tmp=${filename//"${SEP_POLI_AUTHORS_MP3}"/${SEP_MONO}}
	local authors
	local mp3
	IFS="${SEP_MONO}" read authors mp3 <<< "$tmp"
	
	if 	[[ "$keyword" == "authors" ]]; then
		echo "$authors"
	elif 	[[ "$keyword" == "mp3" ]]; then
		echo "$mp3"
	fi
}

function divide-authors (){
	assert-arg-count "divide-authors" "==" 1 "$@"
	local authors_string="$1"
	local authors=${authors_string//"${SEP_POLI_AUTHOR_AUTHOR}"/"${SEP_MONO}"}
	echo "$authors"
	
}

function config () {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "config" ">" 0 "$@"

	declare -A items=()

	while [[ "$#" -gt 0 ]]; do
		case $1 in
			configure)
				shift
				config-configure "$@"
				exit 0
				;;
			list)
				shift
				assert-file-exists "$FILE_CONFIG"
				assert-file-readable "$FILE_CONFIG"
				read-config
				config-list "$@"
				output-items
				exit 0
				;;
			get)
				shift
				assert-file-exists "$FILE_CONFIG"
				assert-file-readable "$FILE_CONFIG"
				read-config
				config-get "$@"
				output-items
				exit 0
				;;
			set)	
				shift
				assert-file-exists "$FILE_CONFIG"
				assert-file-readable "$FILE_CONFIG"
				read-config
				config-set "$@"
				output-items
				exit 0
				;;
			*)
				output-failure "unrecognised config option:\"$1\""
				exit 1
				;;
		esac
	done
}
function config-configure () {
	
	directory-config "$DIR_MAIN"
	
	file-configure "$FILE_HELP" "currentdir"
	
	file-configure "$FILE_CONFIG" "backup" "makenew"
	
	if read-config ; then
		output-success "$(basename "$FILE_CONFIG") read"
	else
		output-failure "$(basename "$FILE_CONFIG") failed to read"
		exit 1
	fi
	
	directory-config "$DIR_MP3S"

	directory-config "$DIR_PLAY"
}

function config-list () {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "config-list" "==" 0 "$@"

	local configuration
	for configuration in "${CONFIGS_ALL[@]}"; do
		# i do not need to check for validity of $configuration here
		# for $configuration is fetched directly from $CONFIG_VALUES
		add-item "	$configuration	-> 	${CONFIG_VALUES[$configuration]} "
	done
}

function config-get () {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "config-get" "==" 1 "$@"
	local configuration="$1"
	if ! is-element-in-array "$configuration" "CONFIGS_ALL"; then
		output-failure "\"$configuration\" invalid configuration"
		exit 1
	fi
	add-item "	$configuration	-> 	${CONFIG_VALUES[$configuration]} "
}

function config-set () {
	# PLACEHOLDER FOR A USER-FRIENDLY ERROR
	assert-arg-count "config-set" "==" 2 "$@"

	local configuration="$1"
	local newvalue="$2"
	if ! is-element-in-array "$configuration" "CONFIGS_ALL"; then
		output-failure "\"$configuration\" invalid configuration"
		exit 1
	fi
	if ! is-element-in-array "$configuration" "CONFIGS_MUTABLE"; then
		output-failure "\"$configuration\" configuration not mutable"
		exit 1
	fi

	assert-file-exists 	"$FILE_CONFIG"
	update-config-file "$configuration" "$newvalue"
}

function update-config-file () {
	assert-arg-count "update-config-file" "==" 2 "$@"
	local configuration="$1"
	local newvalue="$2"

	assert-file-exists 	"$FILE_CONFIG"
	assert-file-readable 	"$FILE_CONFIG"
	assert-file-writable 	"$FILE_CONFIG"
	sed -i "/^${configuration}=/d" "$FILE_CONFIG"
	echo "${configuration}=${newvalue}" >> "$FILE_CONFIG"
}

function directory-config () {
	# configure directory creation for eg. config configure
	# return to execution on success, exit 1 on failure
		# failures:
			# could not create directory
			# directory is a file rather than a directory
			# directory is not readable
	# arguments:
		# full path of the directory
	assert-arg-count "directory-config" "==" 1 "$@"
	local dir="$1"
	local dirname="$(basename "$dir" )"
	if ! is-file-directory-exists "$dir"; then
		output-info "\"$dirname\" does not exist"
		# is-file-directory-exists will omit ${dir%/} 
		# but mkdir treats $dir and ${dir%/} the same
		# and will fail if ${dir%/} exists
		if is-file-exists "${dir%/}"; then
			output-failure "\"$dirname\" can't be created because \"${dir%/}\" file exists"
			exit 1
		fi
		mkdir "$dir"
		if ! [[ $? -eq 0 ]]; then
			output-failure "\"$dirname\" failed to create"
			exit 1
		fi
		output-info "\"$dirname\" created"
	fi
	output-info "\"$dirname\" exists"

	assert-file-directory "$dir"

	output-info "\"$dirname\" is a directory"

	assert-file-readable "$dir"

	output-info "\"$dirname\" is readable"
}


function file-configure () {
	assert-arg-count "file-configure" ">" 1 "$@"
	local file="$1"
	local filename="$( basename "$file" )"
	local backup=0
	local currentdir=0
	local makenew=0
	shift
	while [[ "$#" -ne 0 ]]; do
		case $1 in 
			"backup")
				backup=1
				shift
				;;
			"currentdir")
				currentdir=1
				shift
				;;
			"makenew")
				makenew=1
				shift
				;;
			*)
				output-failure "unrecognised file-configure option:\"$1\""
				return 1
				;;
		esac
	done

	if is-file-exists "$file"; then
		output-info "$filename exists"
		return 0
	fi
	output-info "$filename does not exist"
	
	if [[ $backup -eq 1 ]]; then
		local fileback="${file}${EXT_BKUP}"
		if is-file-exists "$fileback"; then
			cp "$fileback" "$file"
			if [[ $? -eq 0 ]]; then
				output-success "$filename created from backup"
				return
			fi
			output-info "$filename failed to create from backup"
		fi
		output-info "$filename does not have a backup"
	fi

	if [[ $currentdir -eq 1 ]]; then
		if is-file-exists "$filename"; then
			cp "$filename" "$file"
			if [[ $? -eq 0 ]]; then
				output-success "$filename created from current directory"
				return
			fi
			output-info "$filename failed to create from current directory"
		fi
		output-info "$filename not found in current directory"
	fi

	if [[ $makenew -eq 1 ]]; then
		touch "$file"
		if [[ $? -eq 0 ]]; then
			output-success "$filename created blank"
			return 0
		fi
		output-failure "$filename failed to create blank"
	fi
	
	output-failure "$filename configuration failed"
	exit 1 
}

function read-config () {
	assert-file-readable "$FILE_CONFIG"
	while read line ; do
		local argument="$(echo "$line" | cut -d "=" -f 1)"
		case "$argument" in
			"DIR_MP3S")
				local value="$(echo "$line" | cut -d "=" -f 2)"
				DIR_MP3S="$value"
				CONFIG_VALUES["DIR_MP3S"]="$value"
				;;
			"DIR_PLAY")
				local value="$(echo "$line" | cut -d "=" -f 2)"
				DIR_PLAY="$value"
				CONFIG_VALUES["DIR_PLAY"]="$value"
				;;
			*)
				output-failure "not valid user config: \"$argument\""
				return 1
				;;
		esac
	done < "$FILE_CONFIG"
}

function get-config () {
	assert-arg-count "get-config" "==" 1 "$@"
	local configuration="$1"
    	output-info "	$configuration-> 	${CONFIG_VALUES[$configuration]} "
}

function assert-directory-not-empty () {
	# check if directory is empty
	# assumption: directory exists and is readable
	# return to execution flow on success, exit on failure
		# success -> directory is not empty 
		# failure -> directory is empty
	# 1 argument: the directory
	assert-arg-count "assert-directory-not-empty" "==" 1 "$@"
	local directory="$1"

	if ! find "$directory" -mindepth 1 -maxdepth 1 | read; then
		output-failure "\"$directory\" is empty"
		exit 1
	fi
}

function assert-file-writable () {
	# check if file is writable
	# return to execution flow no success, exit on failure
	# Assumption: file exists
	# 1 argument: 
		# full path to the file
	assert-arg-count "assert-file-writable" "==" 1 "$@"
	local file="$1"
	file="${file%/}"	# trim slash if file given for when the file given is a directory.
	if ! [[ -w "$file" ]]; then
		output-failure "\"$(basename "$file")\" not writable"
		exit 1
	fi

}

function assert-file-readable () {
	# check if file is readable
	# Assumption: file exists
	# return to execution flow on success, exit on failure
		# success -> file is readable
		# failure -> file is not readable
	# 1 argument: the file
	assert-arg-count "assert-file-readable" "==" 1 "$@"
	local file="$1"
	file="${file%/}"	# trim slash if file given for when the file given is a directory.
	local filename="$(basename "$file")"
	if ! [[ -r "$file" ]]; then
		output-failure "\"$filename\" not readable"
		exit 1
	fi
}

function assert-file-exists (){
	# check for file existence
	# return execution flow if file exists, exit 1 otherwise
	# 1 argument:
		# the full path to the file
	assert-arg-count "assert-file-exists" "==" 1 "$@"
	local file="$1"
	if ! [[ -e "$file" ]]; then
		output-failure "\"$file\" does not exist"
		exit 1
	fi
}

function is-file-exists () {
	# determine if file exists
	# return 0 if file exists, return 1 if file does not exist
	# 1 argument:
		# the full path to the file
	assert-arg-count "is-file-exists" "==" 1 "$@"
	local file="$1"
	if [[ -e "$file" ]]; then
		return 0
	fi
	return 1
}

function is-file-directory-exists () {
	# determine if file exists and is a directory
	# return 0 if file exists and is a directory, return 0 otherwise
	# 1 argument:
		# the full path to the file
	assert-arg-count "is-file-directory-exists" "==" 1 "$@"
	local file="$1"
	if [[ -d "$file" ]]; then
		return 0
	fi
	return 1
}

function assert-file-directory () {
	# determine if file exists and is a directory
	# return execution flow on success, exit 1 on failure
	# 1 argument:
		# the full path to the file
	assert-arg-count "assert-file-directory" "==" 1 "$@"
	local file="$1"
	local filename="$(basename "$file")"
	if ! [[ -d "$file" ]]; then
		output-failure "\"$filename\" not a directory"
		exit 1
	fi
}

function assert-arg-count () {
	# Check if function given correct arg amount.
	# return execution flow on success, exit 1 on failure
		# success: correct arg count given to function
		# failure:
			# wrong arg count given to assert-corr...
			# invalid operator given
			# assertion failed
	# Arguments:
		# func 				-> name of function (needed for failure output)
		# operator 			-> keyword together with argcount specifying the argument count
		# argcount 			-> a point of refrence for arguments expected
		# optional arguments... 	-> arguments given originally to func
	# the func arguments need to be inputted with [@] (protect from "My Argument" arguments with [*])
	if ! [[ $# -ge 3 ]]; then
		output-failure "assert-arg-count: invalid argument count(must be >= 3, but {$#} were given)"
		exit 1
	fi
	local func="$1"


	local operator="$2"
	local accepted_operators=( "==" ">" "<" )
	# cant use is-element-in-array here, at it produces an infinite loop
	local accepted_operator
	local inside=0
	for accepted_operator in "${accepted_operators[@]}"; do
		if [[ "$accepted_operator" == "$operator" ]]; then
			inside=1
		fi
	done
	if ! [[ $inside -eq 1 ]]; then
		output-failure "assert-arg-count: \"$operator\" not a valid operator( one of: ${accepted_operators[*]})"
		exit 1
	fi
	local argcount="$3"
	local positive_num_re="^[0-9]+$"
	if ! [[ $argcount =~ $positive_num_re ]]; then
		output-failure "assert-arg-count: \"$argcount\" not a valid positive integer"
		exit 1
	fi

	shift 3

	if  ( [[ "$operator" == ">"  ]] &&  ! [[ $# -gt $argcount ]] ) || \
	    ( [[ "$operator" == "==" ]] &&  ! [[ $# -eq $argcount ]] ) || \
	    ( [[ "$operator" == "<"  ]] &&  ! [[ $# -lt $argcount ]] ) ; then

		output-failure "${func}: invalid argument count($# !${operator} $argcount)"
		exit 1
	fi
}

function add-item () {
	# add string item to items with initalized count, or if already exists: increase counter.
	# return to execution flow on success, exit on failure
		# failure -> invalid argument count
	# 1 argument: 
		# string item to be added 
	assert-arg-count "add-item" "==" 1 "$@"
	local new_item="$1"
	local items_array=("${!items[@]}")
	if is-element-in-array "$new_item" "items_array"; then
		items["$new_item"]=$(( ${items["$new_item"]} + 1 ))
	else
		items["$new_item"]=$(( 1 ))
	fi
}

function is-element-in-array() {
	# checks if argument is in array
	# return 0 if yes, 1 if not, exit 1 on failure
		# failure:
			# wrong arg count
	# 2 arguments
		# 1) element to be checked
		# 2) name of array
	assert-arg-count "is-element-in-array" "==" 2 "$@"
	local element="$1"
	local arraynameargs="$2[@]"
	local array=("${!arraynameargs}")		# "(" ")" to treat as array
	local array_element
	for array_element in "${array[@]}"; do
		if [[ "$array_element" == "$element" ]]; then
			return 0
		fi
	done
	return 1
}

function is-line-in-file() {
	# checks if given line in given file
	# assumption: 
		# file exists and is readable
	# return 0 if yes, 1 if not, exit 1 on failure
		# failure:
			# wrong arg count
	# 2 arguments
		# 1) line
		# 2) full path to file
	assert-arg-count "is-line-in-file" "==" 2 "$@"
	local target_line="$1"
	local file="$2"
	local line
	while read line; do
		if [[ "$line" == "$target_line" ]]; then
			return 0
		fi
	done <"$file"
	return 1
}

function output-success () {
	# unifying user success output
	# 1 argument: 
		# the string to output
	assert-arg-count "output-success" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local green="\e[1;32m"
	>&2 echo -e "${white}(${green}+${white}) ${output}."
}

function output-failure () {
	# unifying user failure output
	# 1 argument: 
		# the string to output
	assert-arg-count "output-failure" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local red="\e[1;31m"
	>&2 echo -e "${white}(${red}-${white}) ${output}!"
}

function output-info () {
	# unfying user informative output
	# 1 argument: 
		# the string to output
	assert-arg-count "output-info" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local yellow="\e[1;33m"
	>&2 echo -e "${white}(${yellow}*${white}) ${output}."
}

function output-question () {
	# unifying user prompt output (used in is-confirmed)
	# 1 argument: 
		# the string to output
	assert-arg-count "output-question" "==" 1 "$@"
	local output="$1"
	local white="\e[1;37m"
	local blue="\e[1;34m"
	>&2 echo -ne "${white}(${blue}?${white}) ${output}? "
}

function output-items () {
	# output every item in the global items associative array
	# return to execution flow on success, exit on failure
		# failure -> wrong func arg count
	# no arguments
	# this function should be found after show functions in the show man function.
	assert-arg-count "output-items" "==" 0 "$@"
	local item 
	for item in "${!items[@]}"; do
		if [[ ${items["$item"]} -eq 1 ]] ; then
			echo -e "\t$item"
		else
			echo -e "\t$item \t[${items[$item]}]"
		fi
	done
}

main "$@"
